<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ™ºæ…§åŒ»ç–— - å£°çº¹è¯†åˆ«ç³»ç»Ÿ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'PingFang SC', 'Microsoft YaHei', sans-serif;
            background: #f0f4f8;
            min-height: 100vh;
            padding: 0;
        }

        /* é¡¶éƒ¨å¯¼èˆªæ  */
        .header {
            background: linear-gradient(135deg, #0066cc 0%, #004499 100%);
            color: white;
            padding: 16px 24px;
            box-shadow: 0 2px 8px rgba(0, 102, 204, 0.3);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .header h1 {
            font-size: 22px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .header h1::before {
            content: "ğŸ¥";
            font-size: 28px;
        }

        .header-status {
            display: flex;
            align-items: center;
            gap: 16px;
            font-size: 14px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 24px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
        }

        @media (max-width: 900px) {
            .container {
                grid-template-columns: 1fr;
            }
        }

        .card {
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
            border: 1px solid #e8eef3;
        }

        .card.full-width {
            grid-column: 1 / -1;
        }

        .card h2 {
            color: #0066cc;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 2px solid #e8eef3;
            font-size: 18px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .card h2 .icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #0066cc 0%, #0088ff 100%);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }

        .form-group {
            margin-bottom: 16px;
        }

        label {
            display: block;
            margin-bottom: 6px;
            color: #495057;
            font-weight: 500;
            font-size: 14px;
        }

        input[type="text"],
        input[type="file"],
        input[type="number"],
        select {
            width: 100%;
            padding: 10px 14px;
            border: 1px solid #d1d9e0;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.2s, box-shadow 0.2s;
            background: #fafbfc;
        }

        input[type="text"]:focus,
        input[type="number"]:focus,
        select:focus {
            outline: none;
            border-color: #0066cc;
            box-shadow: 0 0 0 3px rgba(0, 102, 204, 0.1);
            background: white;
        }

        button {
            background: linear-gradient(135deg, #0066cc 0%, #0055aa 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            margin-right: 8px;
            margin-top: 8px;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0, 102, 204, 0.2);
        }

        button:hover {
            background: linear-gradient(135deg, #0077dd 0%, #0066cc 100%);
            box-shadow: 0 4px 8px rgba(0, 102, 204, 0.3);
            transform: translateY(-1px);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        button.secondary {
            background: #6c757d;
            box-shadow: 0 2px 4px rgba(108, 117, 125, 0.2);
        }

        button.secondary:hover {
            background: #5a6268;
        }

        button.success {
            background: linear-gradient(135deg, #28a745 0%, #218838 100%);
            box-shadow: 0 2px 4px rgba(40, 167, 69, 0.2);
        }

        button.warning {
            background: linear-gradient(135deg, #fd7e14 0%, #e8590c 100%);
            box-shadow: 0 2px 4px rgba(253, 126, 20, 0.2);
        }

        button.recording {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.7;
            }
        }

        .result {
            margin-top: 16px;
            padding: 14px;
            border-radius: 6px;
            background: #f8f9fa;
            border-left: 4px solid #0066cc;
            font-size: 13px;
        }

        .result.success {
            border-left-color: #28a745;
            background: #d4edda;
        }

        .result.error {
            border-left-color: #dc3545;
            background: #f8d7da;
        }

        .result pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 12px;
            margin: 0;
        }

        /* å¼¹çª—æ ·å¼ */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 40, 80, 0.6);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(4px);
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            max-width: 800px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: modalSlideIn 0.3s ease;
        }

        @keyframes modalSlideIn {
            from {
                transform: translateY(-30px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-header {
            background: linear-gradient(135deg, #0066cc 0%, #004499 100%);
            color: white;
            padding: 18px 24px;
            border-radius: 12px 12px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h3 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
        }

        .modal-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0;
            padding: 0;
        }

        .modal-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: none;
        }

        .modal-body {
            padding: 24px;
        }

        .medical-section {
            margin-bottom: 20px;
            padding: 16px;
            background: #f8fafc;
            border-radius: 8px;
            border-left: 4px solid #0066cc;
        }

        .medical-section h4 {
            color: #0066cc;
            margin-bottom: 12px;
            font-size: 15px;
            font-weight: 600;
        }

        .medical-section.patient {
            border-left-color: #0066cc;
            background: #e8f4fd;
        }

        .medical-section.patient h4 {
            color: #0066cc;
        }

        .medical-section.doctor {
            border-left-color: #28a745;
            background: #e8f5e9;
        }

        .medical-section.doctor h4 {
            color: #218838;
        }

        .medical-item {
            margin-bottom: 8px;
            line-height: 1.7;
            font-size: 14px;
        }

        .medical-item strong {
            color: #333;
            font-weight: 600;
        }

        .medical-summary {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            padding: 16px;
            border-radius: 8px;
            margin-top: 20px;
            border: 1px solid #90caf9;
        }

        .conversation-preview {
            max-height: 300px;
            overflow-y: auto;
            background: #fff;
            padding: 14px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #e0e0e0;
            font-size: 14px;
        }

        .config-section {
            background: #f8fafc;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .status {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
        }

        .status.online {
            background: #d4edda;
            color: #155724;
        }

        .status.offline {
            background: #f8d7da;
            color: #721c24;
        }

        .audio-player {
            margin-top: 10px;
            width: 100%;
        }

        .audio-source-tabs {
            display: flex;
            margin-bottom: 16px;
            border-bottom: 2px solid #e0e0e0;
        }

        .tab-btn {
            background: none;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            color: #666;
            font-size: 14px;
            border-bottom: 2px solid transparent;
            margin-bottom: -2px;
            margin-right: 0;
            margin-top: 0;
            box-shadow: none;
        }

        .tab-btn.active {
            color: #0066cc;
            border-bottom-color: #0066cc;
        }

        .tab-btn:hover {
            color: #0066cc;
            transform: none;
            box-shadow: none;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .record-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .record-time {
            font-size: 24px;
            font-weight: bold;
            color: #0066cc;
            min-width: 80px;
        }

        .visualizer {
            width: 100%;
            height: 60px;
            background: #f0f0f0;
            border-radius: 8px;
            margin-top: 10px;
        }

        .audio-info {
            margin-top: 10px;
            padding: 10px;
            background: #e9ecef;
            border-radius: 6px;
            font-size: 13px;
            color: #495057;
        }

        .converting {
            color: #0066cc;
            font-style: italic;
        }

        .visualizer {
            width: 100%;
            height: 50px;
            background: linear-gradient(135deg, #e8f4fd 0%, #f0f4f8 100%);
            border-radius: 6px;
            margin-top: 10px;
            border: 1px solid #d1d9e0;
        }

        /* æ‚£è€…ä¿¡æ¯åŒºåŸŸ */
        .patient-info-box {
            background: linear-gradient(135deg, #e8f4fd 0%, #f0f8ff 100%);
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #b3d7f5;
        }

        .patient-info-box strong {
            color: #0066cc;
            display: block;
            margin-bottom: 12px;
            font-size: 14px;
        }

        .patient-info-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
        }

        /* æç¤ºæ¡† */
        .info-box {
            background: #fff3cd;
            padding: 12px 16px;
            border-radius: 6px;
            margin-bottom: 16px;
            font-size: 13px;
            border: 1px solid #ffc107;
            color: #856404;
        }

        .info-box.blue {
            background: #e8f4fd;
            border-color: #0066cc;
            color: #004085;
        }
    </style>
</head>

<body>
    <!-- é¡¶éƒ¨å¯¼èˆª -->
    <div class="header">
        <div class="header-content">
            <h1>å£°çº¹è¯†åˆ«</h1>
            <div class="header-status">
                <span>æœåŠ¡çŠ¶æ€ï¼š</span>
                <span id="serviceStatus" class="status offline">æœªæ£€æµ‹</span>
            </div>
        </div>
    </div>

    <div class="container">
        <!-- é…ç½®åŒºåŸŸ -->
        <div class="card">
            <h2><span class="icon">âš™ï¸</span> ç³»ç»Ÿé…ç½®</h2>
            <div class="config-section">
                <div class="form-group">
                    <label>API åœ°å€</label>
                    <input type="text" id="apiUrl" value="http://192.168.0.207:8520">
                </div>
                <div class="form-group">
                    <label>API Token</label>
                    <input type="text" id="apiToken" value="b5c31ad0-4ac6-4476-b04f-aec9397420a1">
                </div>
                <button onclick="checkHealth()">æ£€æŸ¥æœåŠ¡çŠ¶æ€</button>
            </div>
            <div class="result" id="healthResult" style="display:none;"></div>
        </div>

        <!-- å£°çº¹æ³¨å†Œ -->
        <div class="card">
            <h2><span class="icon">ğŸ“</span> å£°çº¹æ³¨å†Œ</h2>
            <p style="color:#6c757d; margin-bottom:16px; font-size:14px;">ä¸Šä¼ éŸ³é¢‘æˆ–å½•åˆ¶å£°éŸ³ï¼Œæ³¨å†ŒåŒ»ç”Ÿå£°çº¹ç‰¹å¾</p>
            <div class="form-group">
                <label>è¯´è¯äºº ID</label>
                <input type="text" id="registerSpeakerId" placeholder="ä¾‹å¦‚: zhangsan">
            </div>
            <div class="audio-source-tabs">
                <button class="tab-btn active" onclick="switchTab('register', 'file', this)">ğŸ“ ä¸Šä¼ æ–‡ä»¶</button>
                <button class="tab-btn" onclick="switchTab('register', 'mic', this)">ğŸ™ï¸ éº¦å…‹é£å½•éŸ³</button>
            </div>
            <div id="register-file-tab" class="tab-content active">
                <div class="form-group">
                    <label>éŸ³é¢‘æ–‡ä»¶</label>
                    <input type="file" id="registerAudioFile" accept="audio/*"
                        onchange="handleFileSelect(this, 'register')">
                    <div id="registerFileInfo" class="audio-info" style="display:none;"></div>
                    <audio id="registerFilePlayer" class="audio-player" controls style="display:none;"></audio>
                </div>
            </div>
            <div id="register-mic-tab" class="tab-content">
                <div class="record-controls">
                    <button id="registerRecordBtn" onclick="toggleRecording('register')">ğŸ™ï¸ å¼€å§‹å½•éŸ³</button>
                    <span class="record-time" id="registerRecordTime">00:00</span>
                </div>
                <canvas id="registerVisualizer" class="visualizer"></canvas>
                <audio id="registerMicPlayer" class="audio-player" controls style="display:none;"></audio>
            </div>
            <button onclick="registerVoiceprint()">æ³¨å†Œå£°çº¹</button>
            <div class="result" id="registerResult" style="display:none;"></div>
        </div>

        <!-- é—®è¯Š -->
        <div class="card full-width">
            <h2 style="display:flex;justify-content:space-between;align-items:center;">
                <span><span class="icon">ğŸ¥</span> æ™ºèƒ½é—®è¯Š</span>
                <button onclick="showMedicalHistory()" class="secondary"
                    style="font-size:13px;padding:8px 16px;margin:0;">ğŸ“š å†å²è®°å½•</button>
            </h2>
            <p style="color:#6c757d; margin-bottom:16px; font-size:14px;">å½•åˆ¶åŒ»æ‚£å¯¹è¯ï¼ŒAIè‡ªåŠ¨ç”Ÿæˆç”µå­ç—…å†</p>

            <!-- æ‚£è€…åŸºæœ¬ä¿¡æ¯ -->
            <div class="patient-info-box">
                <strong>ğŸ‘¤ æ‚£è€…åŸºæœ¬ä¿¡æ¯</strong>
                <div class="patient-info-grid">
                    <div class="form-group" style="margin-bottom:0;">
                        <label>å§“å</label>
                        <input type="text" id="patientName" placeholder="è¯·è¾“å…¥å§“å">
                    </div>
                    <div class="form-group" style="margin-bottom:0;">
                        <label>æ€§åˆ«</label>
                        <select id="patientGender">
                            <option value="">è¯·é€‰æ‹©</option>
                            <option value="ç”·">ç”·</option>
                            <option value="å¥³">å¥³</option>
                        </select>
                    </div>
                    <div class="form-group" style="margin-bottom:0;">
                        <label>å¹´é¾„</label>
                        <input type="number" id="patientAge" placeholder="è¯·è¾“å…¥å¹´é¾„" min="0" max="150">
                    </div>
                </div>
            </div>

            <div class="info-box blue">
                <strong>ğŸ’¡ ä½¿ç”¨è¯´æ˜ï¼š</strong>
                1. å¡«å†™æ‚£è€…åŸºæœ¬ä¿¡æ¯ â†’ 2. å½•åˆ¶æˆ–ä¸Šä¼ åŒ»æ‚£å¯¹è¯éŸ³é¢‘ â†’ 3. ç‚¹å‡»"ç”Ÿæˆç”µå­ç—…å†"è‡ªåŠ¨åˆ†æç”Ÿæˆ
            </div>

            <!-- æ¨¡å¼é€‰æ‹© -->
            <div class="audio-source-tabs" style="margin-bottom:16px;">
                <button class="tab-btn active" onclick="switchConversationMode('file', this)">ğŸ“ ä¸Šä¼ æ–‡ä»¶</button>
                <button class="tab-btn" onclick="switchConversationMode('record', this)">ğŸ™ï¸ å½•éŸ³è¯†åˆ«</button>
                <button class="tab-btn" onclick="switchConversationMode('realtime', this)">âš¡ å®æ—¶è¯†åˆ«</button>
            </div>

            <!-- ä¸Šä¼ æ–‡ä»¶æ¨¡å¼ -->
            <div id="conversation-file-mode" class="tab-content active">
                <div class="form-group">
                    <label>éŸ³é¢‘æ–‡ä»¶</label>
                    <input type="file" id="conversationAudioFile" accept="audio/*"
                        onchange="handleFileSelect(this, 'conversation')">
                    <div id="conversationFileInfo" class="audio-info" style="display:none;"></div>
                    <audio id="conversationFilePlayer" class="audio-player" controls style="display:none;"></audio>
                </div>
                <div style="display:flex;gap:10px;flex-wrap:wrap;">
                    <button id="conversationFileMedicalBtn" onclick="generateMedicalRecordFromFile()" class="warning">ğŸ“‹
                        ç”Ÿæˆç”µå­ç—…å†</button>
                </div>
            </div>

            <!-- å½•éŸ³æ¨¡å¼ -->
            <div id="conversation-record-mode" class="tab-content">
                <div class="record-controls">
                    <button id="conversationRecordBtn" onclick="toggleRecording('conversation')">ğŸ™ï¸ å¼€å§‹å½•éŸ³</button>
                    <span class="record-time" id="conversationRecordTime">00:00</span>
                </div>
                <canvas id="conversationVisualizer" class="visualizer"></canvas>
                <audio id="conversationMicPlayer" class="audio-player" controls style="display:none;"></audio>
                <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:10px;">
                    <button id="conversationRecordMedicalBtn" onclick="generateMedicalRecordFromFile()"
                        class="warning">ğŸ“‹ ç”Ÿæˆç”µå­ç—…å†</button>
                </div>
            </div>

            <!-- å®æ—¶è¯†åˆ«æ¨¡å¼ -->
            <div id="conversation-realtime-mode" class="tab-content">
                <div class="record-controls">
                    <button id="realtimeBtn" onclick="toggleRealtime()" class="success">âš¡ å¼€å§‹å®æ—¶è¯†åˆ«</button>
                    <span class="record-time" id="realtimeTime">00:00</span>
                    <span id="realtimeStatus" style="color:#6c757d;margin-left:10px;font-size:13px;">æœªè¿æ¥</span>
                </div>
                <canvas id="realtimeVisualizer" class="visualizer"></canvas>
                <div id="realtimeMessages"
                    style="font-size:14px; line-height:1.8; min-height:100px; max-height:300px; overflow-y:auto; background:#f8f9fa; padding:10px; border-radius:8px; margin-top:10px;">
                </div>
                <button id="generateRecordBtn" onclick="generateMedicalRecordFromRealtime()" class="warning"
                    style="margin-top:10px;">ğŸ“‹ ç”Ÿæˆç”µå­ç—…å†</button>
            </div>

            <!-- è¯†åˆ«ç»“æœ -->
            <div class="result" id="conversationResult" style="display:none;"></div>
        </div>

        <!-- å£°çº¹ç®¡ç† -->
        <div class="card">
            <h2><span class="icon">ğŸ“‹</span> å£°çº¹ç®¡ç†</h2>
            <div class="form-group">
                <label>è¯´è¯äºº ID</label>
                <input type="text" id="deleteSpeakerId" placeholder="ä¾‹å¦‚: zhangsan">
            </div>
            <button onclick="deleteVoiceprint()">åˆ é™¤å£°çº¹</button>
            <button class="secondary" onclick="listVoiceprints()">æŸ¥çœ‹æ‰€æœ‰å£°çº¹</button>
            <div class="result" id="deleteResult" style="display:none;"></div>
        </div>
    </div>

    <!-- ç”µå­ç—…å†å¼¹çª— -->
    <div id="medicalModal" class="modal-overlay" onclick="closeMedicalModal(event)">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h3>ğŸ“‹ ç”µå­ç—…å†</h3>
                <div style="display:flex;gap:8px;align-items:center;">
                    <button id="exportPdfBtn" onclick="exportPdf()"
                        style="background:rgba(255,255,255,0.2);padding:8px 16px;font-size:14px;margin:0;">ğŸ“„
                        å¯¼å‡ºPDF</button>
                    <button id="editMedicalBtn" onclick="toggleEditMode()"
                        style="background:rgba(255,255,255,0.2);padding:8px 16px;font-size:14px;margin:0;">âœï¸
                        ç¼–è¾‘</button>
                    <button class="modal-close" onclick="closeMedicalModal()">&times;</button>
                </div>
            </div>
            <div class="modal-body" id="medicalModalBody">
                <!-- ç—…å†å†…å®¹å°†åŠ¨æ€å¡«å…… -->
            </div>
        </div>
    </div>

    <!-- å†å²è®°å½•å¼¹çª— -->
    <div id="historyModal" class="modal-overlay" onclick="closeHistoryModal(event)">
        <div class="modal-content" onclick="event.stopPropagation()" style="max-width:900px;">
            <div class="modal-header" style="background:linear-gradient(135deg, #6c757d 0%, #495057 100%);">
                <h3>ğŸ“š ç—…å†å†å²è®°å½•</h3>
                <button class="modal-close" onclick="closeHistoryModal()">&times;</button>
            </div>
            <div class="modal-body" id="historyModalBody">
                <div style="text-align:center;padding:40px;color:#666;">åŠ è½½ä¸­...</div>
            </div>
        </div>
    </div>

    <script>
        const TARGET_SAMPLE_RATE = 16000;
        const recorders = {
            register: { mediaRecorder: null, audioChunks: [], blob: null, isRecording: false, timer: null, seconds: 0 },
            identify: { mediaRecorder: null, audioChunks: [], blob: null, isRecording: false, timer: null, seconds: 0 },
            diarize: { mediaRecorder: null, audioChunks: [], blob: null, isRecording: false, timer: null, seconds: 0 },
            conversation: { mediaRecorder: null, audioChunks: [], blob: null, isRecording: false, timer: null, seconds: 0 }
        };
        const convertedAudio = { register: null, identify: null, diarize: null, conversation: null };
        const activeTab = { register: 'file', identify: 'file', diarize: 'file', conversation: 'file' };

        // å­˜å‚¨å®æ—¶è¯†åˆ«çš„å¯¹è¯è®°å½•ï¼Œç”¨äºç”Ÿæˆç—…å†
        let realtimeConversation = [];

        function switchTab(section, tab, btn) {
            activeTab[section] = tab;
            document.getElementById(`${section}-file-tab`).classList.toggle('active', tab === 'file');
            document.getElementById(`${section}-mic-tab`).classList.toggle('active', tab === 'mic');
            btn.parentElement.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
        }

        let currentConversationMode = 'file';
        function switchConversationMode(mode, btn) {
            currentConversationMode = mode;
            document.getElementById('conversation-file-mode').classList.toggle('active', mode === 'file');
            document.getElementById('conversation-record-mode').classList.toggle('active', mode === 'record');
            document.getElementById('conversation-realtime-mode').classList.toggle('active', mode === 'realtime');
            btn.parentElement.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            // å¦‚æœåˆ‡æ¢åˆ°å…¶ä»–æ¨¡å¼ï¼Œåœæ­¢å®æ—¶è¯†åˆ«
            if (mode !== 'realtime' && isRealtimeRunning) {
                stopRealtime();
            }
        }

        async function handleFileSelect(input, section) {
            const file = input.files[0];
            if (!file) return;
            const infoEl = document.getElementById(`${section}FileInfo`);
            const playerEl = document.getElementById(`${section}FilePlayer`);
            infoEl.style.display = 'block';
            infoEl.innerHTML = '<span class="converting">â³ æ­£åœ¨è½¬æ¢éŸ³é¢‘æ ¼å¼...</span>';
            try {
                const audioContext = new AudioContext({ sampleRate: TARGET_SAMPLE_RATE });
                const arrayBuffer = await file.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                const offlineContext = new OfflineAudioContext(1, audioBuffer.duration * TARGET_SAMPLE_RATE, TARGET_SAMPLE_RATE);
                const source = offlineContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(offlineContext.destination);
                source.start();
                const renderedBuffer = await offlineContext.startRendering();
                const wavBlob = audioBufferToWav(renderedBuffer);
                convertedAudio[section] = wavBlob;
                infoEl.innerHTML = `âœ… è½¬æ¢å®Œæˆ<br>åŸæ ¼å¼: ${file.type || 'æœªçŸ¥'} | åŸå¤§å°: ${(file.size / 1024).toFixed(1)}KB<br>è½¬æ¢å: WAV 16kHz å•å£°é“ | å¤§å°: ${(wavBlob.size / 1024).toFixed(1)}KB`;
                playerEl.src = URL.createObjectURL(wavBlob);
                playerEl.style.display = 'block';
                await audioContext.close();
            } catch (error) {
                infoEl.innerHTML = `âŒ è½¬æ¢å¤±è´¥: ${error.message}`;
                convertedAudio[section] = null;
            }
        }

        function audioBufferToWav(buffer) {
            const numChannels = buffer.numberOfChannels;
            const sampleRate = buffer.sampleRate;
            const format = 1;
            const bitDepth = 16;
            const bytesPerSample = bitDepth / 8;
            const blockAlign = numChannels * bytesPerSample;
            const data = buffer.getChannelData(0);
            const samples = data.length;
            const dataSize = samples * bytesPerSample;
            const bufferSize = 44 + dataSize;
            const arrayBuffer = new ArrayBuffer(bufferSize);
            const view = new DataView(arrayBuffer);
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, format, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * blockAlign, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitDepth, true);
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);
            let offset = 44;
            for (let i = 0; i < samples; i++) {
                const sample = Math.max(-1, Math.min(1, data[i]));
                view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                offset += 2;
            }
            return new Blob([arrayBuffer], { type: 'audio/wav' });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        async function toggleRecording(section) {
            const rec = recorders[section];
            const btn = document.getElementById(`${section}RecordBtn`);
            if (!rec.isRecording) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: { sampleRate: TARGET_SAMPLE_RATE, channelCount: 1 } });
                    rec.mediaRecorder = new MediaRecorder(stream);
                    rec.audioChunks = [];
                    setupVisualizer(section, stream);
                    rec.mediaRecorder.ondataavailable = (e) => rec.audioChunks.push(e.data);
                    rec.mediaRecorder.onstop = async () => {
                        const blob = new Blob(rec.audioChunks, { type: 'audio/webm' });
                        const audioContext = new AudioContext({ sampleRate: TARGET_SAMPLE_RATE });
                        const arrayBuffer = await blob.arrayBuffer();
                        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                        const wavBlob = audioBufferToWav(audioBuffer);
                        rec.blob = wavBlob;
                        convertedAudio[section] = wavBlob;
                        const player = document.getElementById(`${section}MicPlayer`);
                        player.src = URL.createObjectURL(wavBlob);
                        player.style.display = 'block';
                        stream.getTracks().forEach(track => track.stop());
                        await audioContext.close();
                    };
                    rec.mediaRecorder.start();
                    rec.isRecording = true;
                    rec.seconds = 0;
                    btn.textContent = 'â¹ï¸ åœæ­¢å½•éŸ³';
                    btn.classList.add('recording');
                    rec.timer = setInterval(() => {
                        rec.seconds++;
                        document.getElementById(`${section}RecordTime`).textContent = `${Math.floor(rec.seconds / 60).toString().padStart(2, '0')}:${(rec.seconds % 60).toString().padStart(2, '0')}`;
                    }, 1000);
                } catch (err) {
                    alert('æ— æ³•è®¿é—®éº¦å…‹é£: ' + err.message);
                }
            } else {
                rec.mediaRecorder.stop();
                rec.isRecording = false;
                clearInterval(rec.timer);
                btn.textContent = 'ğŸ™ï¸ å¼€å§‹å½•éŸ³';
                btn.classList.remove('recording');
            }
        }

        function setupVisualizer(section, stream) {
            const canvas = document.getElementById(`${section}Visualizer`);
            const ctx = canvas.getContext('2d');
            const audioCtx = new AudioContext();
            const analyser = audioCtx.createAnalyser();
            audioCtx.createMediaStreamSource(stream).connect(analyser);
            analyser.fftSize = 256;
            const dataArray = new Uint8Array(analyser.frequencyBinCount);
            function draw() {
                if (!recorders[section].isRecording) return;
                requestAnimationFrame(draw);
                analyser.getByteFrequencyData(dataArray);
                ctx.fillStyle = '#f0f0f0';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                const barWidth = (canvas.width / dataArray.length) * 2.5;
                let x = 0;
                for (let i = 0; i < dataArray.length; i++) {
                    ctx.fillStyle = `rgb(102, ${126 + dataArray[i] / 2}, 234)`;
                    ctx.fillRect(x, canvas.height - (dataArray[i] / 255) * canvas.height, barWidth, (dataArray[i] / 255) * canvas.height);
                    x += barWidth + 1;
                }
            }
            draw();
        }

        function getAudioData(section) {
            if (activeTab[section] === 'file') return convertedAudio[section];
            return recorders[section].blob;
        }

        function getConfig() {
            return {
                apiUrl: document.getElementById('apiUrl').value.replace(/\/$/, ''),
                apiToken: document.getElementById('apiToken').value
            };
        }

        function showResult(elementId, data, isSuccess) {
            const el = document.getElementById(elementId);
            el.style.display = 'block';
            el.className = 'result ' + (isSuccess ? 'success' : 'error');
            el.innerHTML = '<pre>' + JSON.stringify(data, null, 2) + '</pre>';
        }

        async function checkHealth() {
            const config = getConfig();
            const statusEl = document.getElementById('serviceStatus');
            try {
                const response = await fetch(`${config.apiUrl}/voiceprint/health?key=${config.apiToken}`);
                const data = await response.json();
                statusEl.textContent = 'åœ¨çº¿';
                statusEl.className = 'status online';
                showResult('healthResult', data, true);
            } catch (error) {
                statusEl.textContent = 'ç¦»çº¿';
                statusEl.className = 'status offline';
                showResult('healthResult', { error: error.message }, false);
            }
        }

        async function registerVoiceprint() {
            const config = getConfig();
            const speakerId = document.getElementById('registerSpeakerId').value;
            const audioData = getAudioData('register');
            if (!speakerId) { alert('è¯·è¾“å…¥è¯´è¯äºº ID'); return; }
            if (!audioData) { alert('è¯·é€‰æ‹©éŸ³é¢‘æ–‡ä»¶æˆ–å½•åˆ¶å£°éŸ³'); return; }
            const formData = new FormData();
            formData.append('speaker_id', speakerId);
            formData.append('file', audioData, 'audio.wav');
            try {
                const response = await fetch(`${config.apiUrl}/voiceprint/register`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${config.apiToken}` },
                    body: formData
                });
                const data = await response.json();
                showResult('registerResult', data, response.ok);
            } catch (error) {
                showResult('registerResult', { error: error.message }, false);
            }
        }

        async function identifyVoiceprint() {
            const config = getConfig();
            const audioData = getAudioData('identify');
            let speakerIds = document.getElementById('identifySpeakerIds').value.trim();
            if (!audioData) { alert('è¯·é€‰æ‹©éŸ³é¢‘æ–‡ä»¶æˆ–å½•åˆ¶å£°éŸ³'); return; }
            const formData = new FormData();
            formData.append('file', audioData, 'audio.wav');
            // ç•™ç©ºåˆ™ä»æ•°æ®åº“å…¨éƒ¨æ¯”å¯¹
            if (speakerIds) {
                formData.append('speaker_ids', speakerIds);
            }
            try {
                const response = await fetch(`${config.apiUrl}/voiceprint/identify`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${config.apiToken}` },
                    body: formData
                });
                const data = await response.json();
                showResult('identifyResult', data, response.ok);
            } catch (error) {
                showResult('identifyResult', { error: error.message }, false);
            }
        }

        async function deleteVoiceprint() {
            const config = getConfig();
            const speakerId = document.getElementById('deleteSpeakerId').value;
            if (!speakerId) { alert('è¯·è¾“å…¥è¯´è¯äºº ID'); return; }
            try {
                const response = await fetch(`${config.apiUrl}/voiceprint/${speakerId}`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `Bearer ${config.apiToken}` }
                });
                const data = await response.json();
                showResult('deleteResult', data, response.ok);
            } catch (error) {
                showResult('deleteResult', { error: error.message }, false);
            }
        }

        async function listVoiceprints() {
            const config = getConfig();
            try {
                const response = await fetch(`${config.apiUrl}/voiceprint/list`, {
                    headers: { 'Authorization': `Bearer ${config.apiToken}` }
                });
                const data = await response.json();

                // æ ¼å¼åŒ–æ˜¾ç¤º
                if (response.ok && data.voiceprints) {
                    let html = `<div style="margin-bottom:10px;"><strong>å…± ${data.total} ä¸ªå·²æ³¨å†Œå£°çº¹</strong></div>`;
                    if (data.voiceprints.length > 0) {
                        html += '<table style="width:100%;border-collapse:collapse;font-size:13px;">';
                        html += '<tr style="background:#667eea;color:white;"><th style="padding:8px;text-align:left;">è¯´è¯äººID</th><th style="padding:8px;text-align:left;">æ³¨å†Œæ—¶é—´</th></tr>';
                        data.voiceprints.forEach((v, i) => {
                            const bg = i % 2 === 0 ? '#f8f9fa' : '#ffffff';
                            html += `<tr style="background:${bg};"><td style="padding:8px;">${v.speaker_id}</td><td style="padding:8px;">${v.created_at || '-'}</td></tr>`;
                        });
                        html += '</table>';
                    }
                    document.getElementById('deleteResult').style.display = 'block';
                    document.getElementById('deleteResult').className = 'result success';
                    document.getElementById('deleteResult').innerHTML = html;
                } else {
                    showResult('deleteResult', data, response.ok);
                }
            } catch (error) {
                showResult('deleteResult', { error: error.message }, false);
            }
        }

        async function diarizeVoiceprint() {
            const config = getConfig();
            const audioData = getAudioData('diarize');
            let speakerIds = document.getElementById('diarizeSpeakerIds').value.trim();
            if (!audioData) { alert('è¯·é€‰æ‹©éŸ³é¢‘æ–‡ä»¶æˆ–å½•åˆ¶å£°éŸ³'); return; }
            const formData = new FormData();
            formData.append('file', audioData, 'audio.wav');
            formData.append('speaker_ids', speakerIds);
            const btn = document.getElementById('diarizeBtn');
            btn.disabled = true;
            btn.textContent = 'â³ è¯†åˆ«ä¸­...';
            try {
                const response = await fetch(`${config.apiUrl}/voiceprint/diarize`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${config.apiToken}` },
                    body: formData
                });
                const data = await response.json();
                if (response.ok && data.segments) {
                    let html = `<div style="margin-bottom:10px;"><strong>æ£€æµ‹åˆ° ${data.speaker_count} ä¸ªè¯´è¯äººï¼Œå…± ${data.segments.length} ä¸ªç‰‡æ®µ</strong></div>`;
                    html += '<table style="width:100%;border-collapse:collapse;font-size:13px;">';
                    html += '<tr style="background:#667eea;color:white;"><th style="padding:8px;text-align:left;">æ—¶é—´æ®µ</th><th style="padding:8px;text-align:left;">è¯†åˆ«ç»“æœ</th><th style="padding:8px;text-align:left;">ç›¸ä¼¼åº¦</th><th style="padding:8px;text-align:left;">åˆ†ç¦»æ ‡ç­¾</th></tr>';
                    data.segments.forEach((seg, i) => {
                        const bgColor = i % 2 === 0 ? '#f8f9fa' : '#ffffff';
                        const speakerDisplay = seg.speaker_id || '<span style="color:#999;">æœªè¯†åˆ«</span>';
                        const scoreDisplay = seg.score > 0 ? (seg.score * 100).toFixed(1) + '%' : '-';
                        html += `<tr style="background:${bgColor};"><td style="padding:8px;">${seg.start.toFixed(2)}s - ${seg.end.toFixed(2)}s</td><td style="padding:8px;">${speakerDisplay}</td><td style="padding:8px;">${scoreDisplay}</td><td style="padding:8px;">${seg.diarization_label}</td></tr>`;
                    });
                    html += '</table>';
                    const el = document.getElementById('diarizeResult');
                    el.style.display = 'block';
                    el.className = 'result success';
                    el.innerHTML = html;
                } else {
                    showResult('diarizeResult', data, response.ok);
                }
            } catch (error) {
                showResult('diarizeResult', { error: error.message }, false);
            } finally {
                btn.disabled = false;
                btn.textContent = 'å¤šäººè¯†åˆ«';
            }
        }

        async function conversationRecognize() {
            const config = getConfig();
            // æ ¹æ®å½“å‰æ¨¡å¼è·å–éŸ³é¢‘æ•°æ®
            let audioData;
            if (currentConversationMode === 'file') {
                audioData = convertedAudio['conversation'];
            } else if (currentConversationMode === 'record') {
                audioData = recorders['conversation'].blob || convertedAudio['conversation'];
            }
            let speakerIds = document.getElementById('conversationSpeakerIds').value.trim();
            if (!audioData) { alert('è¯·é€‰æ‹©éŸ³é¢‘æ–‡ä»¶æˆ–å½•åˆ¶å£°éŸ³'); return; }
            const formData = new FormData();
            formData.append('file', audioData, 'audio.wav');
            formData.append('speaker_ids', speakerIds);
            const btn = currentConversationMode === 'file' ? document.getElementById('conversationFileBtn') : document.getElementById('conversationRecordSubmitBtn');
            btn.disabled = true;
            btn.textContent = 'â³ è¯†åˆ«ä¸­...';
            try {
                const response = await fetch(`${config.apiUrl}/voiceprint/conversation`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${config.apiToken}` },
                    body: formData
                });
                const data = await response.json();
                if (response.ok && data.segments) {
                    let html = `<div style="margin-bottom:15px;"><strong>ğŸ¯ æ£€æµ‹åˆ° ${data.speaker_count} ä¸ªè¯´è¯äººï¼Œå…± ${data.segments.length} ä¸ªå¯¹è¯ç‰‡æ®µ</strong></div>`;

                    // å¯¹è¯è®°å½•è¡¨æ ¼
                    html += '<table style="width:100%;border-collapse:collapse;font-size:13px;margin-bottom:20px;">';
                    html += '<tr style="background:#667eea;color:white;"><th style="padding:8px;text-align:left;">æ—¶é—´</th><th style="padding:8px;text-align:left;">è¯´è¯äºº</th><th style="padding:8px;text-align:left;">ç›¸ä¼¼åº¦</th><th style="padding:8px;text-align:left;">å†…å®¹</th></tr>';
                    data.segments.forEach((seg, i) => {
                        const bgColor = i % 2 === 0 ? '#f8f9fa' : '#ffffff';
                        const speakerDisplay = seg.speaker_id || `<span style="color:#999;">${seg.diarization_label}</span>`;
                        const scoreDisplay = seg.score > 0 ? (seg.score * 100).toFixed(1) + '%' : '-';
                        const textDisplay = seg.text || '<span style="color:#999;">ï¼ˆæ— è½¬å†™ï¼‰</span>';
                        html += `<tr style="background:${bgColor};">
                            <td style="padding:8px;white-space:nowrap;">${seg.start.toFixed(1)}s - ${seg.end.toFixed(1)}s</td>
                            <td style="padding:8px;">${speakerDisplay}</td>
                            <td style="padding:8px;">${scoreDisplay}</td>
                            <td style="padding:8px;">${textDisplay}</td>
                        </tr>`;
                    });
                    html += '</table>';

                    // å®Œæ•´å¯¹è¯æ–‡æœ¬
                    if (data.transcript) {
                        html += '<div style="background:#f0f7ff;padding:15px;border-radius:8px;border-left:4px solid #667eea;">';
                        html += '<strong style="display:block;margin-bottom:10px;">ğŸ“ å®Œæ•´å¯¹è¯è®°å½•ï¼š</strong>';
                        html += '<pre style="white-space:pre-wrap;word-wrap:break-word;margin:0;font-family:inherit;line-height:1.6;">' + data.transcript + '</pre>';
                        html += '</div>';
                    }

                    const el = document.getElementById('conversationResult');
                    el.style.display = 'block';
                    el.className = 'result success';
                    el.innerHTML = html;
                } else {
                    showResult('conversationResult', data, response.ok);
                }
            } catch (error) {
                showResult('conversationResult', { error: error.message }, false);
            } finally {
                btn.disabled = false;
                btn.textContent = currentConversationMode === 'file' ? 'ğŸ¯ è¯†åˆ«å¯¹è¯' : 'ğŸ¯ è¯†åˆ«å½•éŸ³';
            }
        }

        // ========== å®æ—¶å¯¹è¯è¯†åˆ« ==========
        let realtimeWs = null;
        let realtimeStream = null;
        let realtimeProcessor = null;
        let realtimeContext = null;
        let realtimeTimer = null;
        let realtimeSeconds = 0;
        let isRealtimeRunning = false;

        // ç”¨äºåˆå¹¶åŒä¸€è¯´è¯äººè¿ç»­æ¶ˆæ¯
        let lastSpeaker = null;
        let lastMessageEl = null;
        let speakerColors = {};
        const colorPalette = ['#667eea', '#28a745', '#dc3545', '#fd7e14', '#6f42c1', '#20c997', '#e83e8c'];
        let colorIndex = 0;

        function getSpeakerColor(speaker) {
            if (!speakerColors[speaker]) {
                speakerColors[speaker] = colorPalette[colorIndex % colorPalette.length];
                colorIndex++;
            }
            return speakerColors[speaker];
        }

        async function toggleRealtime() {
            if (isRealtimeRunning) {
                stopRealtime();
            } else {
                await startRealtime();
            }
        }

        async function startRealtime() {
            const config = getConfig();
            const speakerIds = document.getElementById('conversationSpeakerIds').value.trim();
            const btn = document.getElementById('realtimeBtn');
            const statusEl = document.getElementById('realtimeStatus');
            const messagesEl = document.getElementById('realtimeMessages');

            // é‡ç½®çŠ¶æ€
            lastSpeaker = null;
            lastMessageEl = null;
            speakerColors = {};
            colorIndex = 0;

            try {
                // è·å–éº¦å…‹é£æƒé™
                realtimeStream = await navigator.mediaDevices.getUserMedia({
                    audio: { sampleRate: TARGET_SAMPLE_RATE, channelCount: 1 }
                });

                // å»ºç«‹ WebSocket è¿æ¥
                const wsUrl = config.apiUrl.replace('http', 'ws') + `/voiceprint/realtime?token=${config.apiToken}&speaker_ids=${speakerIds}`;
                realtimeWs = new WebSocket(wsUrl);

                realtimeWs.onopen = () => {
                    statusEl.textContent = 'å·²è¿æ¥';
                    statusEl.style.color = '#28a745';
                    messagesEl.innerHTML = '<div style="color:#666;text-align:center;padding:20px;">ğŸ¤ å¼€å§‹è¯´è¯...</div>';

                    // å¼€å§‹å‘é€éŸ³é¢‘æ•°æ®
                    startAudioCapture();
                };

                realtimeWs.onmessage = (event) => {
                    const result = JSON.parse(event.data);
                    const speaker = result.speaker_id || 'æœªçŸ¥';
                    const role = result.role || (result.speaker_id ? 'åŒ»ç”Ÿ' : 'æ‚£è€…/å®¶å±');
                    const text = result.text || '';
                    const score = result.score > 0 ? (result.score * 100).toFixed(0) : 0;

                    // å¦‚æœæ²¡æœ‰è¯†åˆ«åˆ°æ–‡å­—ï¼Œè·³è¿‡æ˜¾ç¤º
                    if (!text.trim()) return;

                    // ä¿å­˜å¯¹è¯è®°å½•ï¼Œç”¨äºç”Ÿæˆç—…å†
                    realtimeConversation.push(result);

                    // æ¸…é™¤åˆå§‹æç¤º
                    if (messagesEl.querySelector('div[style*="text-align:center"]')) {
                        messagesEl.innerHTML = '';
                        realtimeConversation = []; // é‡ç½®å¯¹è¯è®°å½•
                        realtimeConversation.push(result);
                    }

                    const speakerColor = getSpeakerColor(role);
                    const isKnown = result.speaker_id && result.speaker_id !== '';
                    const bgColor = isKnown ? '#e8f5e9' : '#fff3e0';

                    // å¦‚æœæ˜¯åŒä¸€ä¸ªè¯´è¯äººï¼Œè¿½åŠ åˆ°ä¸Šä¸€æ¡æ¶ˆæ¯
                    if (role === lastSpeaker && lastMessageEl) {
                        const textEl = lastMessageEl.querySelector('.msg-text');
                        textEl.innerHTML += ' ' + text;
                        // æ›´æ–°ä¿å­˜çš„å¯¹è¯è®°å½•ï¼ˆåˆå¹¶æ–‡æœ¬ï¼‰
                        if (realtimeConversation.length > 1) {
                            const lastRecord = realtimeConversation[realtimeConversation.length - 2];
                            if (lastRecord.role === role) {
                                lastRecord.text = (lastRecord.text || '') + ' ' + text;
                                realtimeConversation.pop(); // ç§»é™¤åˆšæ·»åŠ çš„é‡å¤è®°å½•
                            }
                        }
                    } else {
                        // æ–°è¯´è¯äººï¼Œåˆ›å»ºæ–°çš„æ¶ˆæ¯æ°”æ³¡ï¼ˆå¾®ä¿¡é£æ ¼ï¼‰
                        const msgDiv = document.createElement('div');
                        msgDiv.style.cssText = 'display:flex;margin-bottom:12px;align-items:flex-start;';

                        // å¤´åƒ
                        const avatar = document.createElement('div');
                        const avatarText = role === 'åŒ»ç”Ÿ' ? 'åŒ»' : 'æ‚£';
                        avatar.style.cssText = `width:36px;height:36px;border-radius:50%;background:${speakerColor};color:white;display:flex;align-items:center;justify-content:center;font-size:14px;font-weight:bold;flex-shrink:0;margin-right:10px;`;
                        avatar.textContent = avatarText;

                        // æ¶ˆæ¯å†…å®¹åŒº
                        const contentDiv = document.createElement('div');
                        contentDiv.style.cssText = 'flex:1;max-width:calc(100% - 50px);';

                        // è¯´è¯äººåç§°å’Œç½®ä¿¡åº¦
                        const nameDiv = document.createElement('div');
                        nameDiv.style.cssText = `font-size:12px;color:${speakerColor};margin-bottom:4px;font-weight:600;`;
                        const displayName = isKnown ? `åŒ»ç”Ÿ(${speaker})` : role;
                        nameDiv.innerHTML = displayName + (score > 0 ? ` <span style="color:#999;font-weight:normal;">(${score}%)</span>` : '');

                        // æ¶ˆæ¯æ°”æ³¡
                        const bubbleDiv = document.createElement('div');
                        bubbleDiv.style.cssText = `background:${bgColor};padding:10px 14px;border-radius:0 12px 12px 12px;display:inline-block;max-width:100%;word-wrap:break-word;line-height:1.5;`;
                        bubbleDiv.innerHTML = `<span class="msg-text">${text}</span>`;

                        contentDiv.appendChild(nameDiv);
                        contentDiv.appendChild(bubbleDiv);
                        msgDiv.appendChild(avatar);
                        msgDiv.appendChild(contentDiv);

                        messagesEl.appendChild(msgDiv);
                        lastMessageEl = msgDiv;
                        lastSpeaker = role;
                    }

                    messagesEl.scrollTop = messagesEl.scrollHeight;
                };

                realtimeWs.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    statusEl.textContent = 'è¿æ¥é”™è¯¯';
                    statusEl.style.color = '#dc3545';
                };

                realtimeWs.onclose = () => {
                    statusEl.textContent = 'å·²æ–­å¼€';
                    statusEl.style.color = '#666';
                    stopRealtime();
                };

                // æ›´æ–°UI
                isRealtimeRunning = true;
                btn.textContent = 'â¹ï¸ åœæ­¢è¯†åˆ«';
                btn.className = 'recording';

                // å¯åŠ¨è®¡æ—¶å™¨
                realtimeSeconds = 0;
                realtimeTimer = setInterval(() => {
                    realtimeSeconds++;
                    document.getElementById('realtimeTime').textContent =
                        `${Math.floor(realtimeSeconds / 60).toString().padStart(2, '0')}:${(realtimeSeconds % 60).toString().padStart(2, '0')}`;
                }, 1000);

                // è®¾ç½®å¯è§†åŒ–
                setupRealtimeVisualizer(realtimeStream);

            } catch (error) {
                alert('å¯åŠ¨å®æ—¶è¯†åˆ«å¤±è´¥: ' + error.message);
                stopRealtime();
            }
        }

        function startAudioCapture() {
            console.log('å¼€å§‹éŸ³é¢‘æ•è·...');
            realtimeContext = new AudioContext({ sampleRate: TARGET_SAMPLE_RATE });
            const source = realtimeContext.createMediaStreamSource(realtimeStream);

            // åˆ›å»º ScriptProcessor æ¥è·å–åŸå§‹éŸ³é¢‘æ•°æ®
            const bufferSize = 4096; // å¢å¤§ç¼“å†²åŒº
            realtimeProcessor = realtimeContext.createScriptProcessor(bufferSize, 1, 1);

            let chunkCount = 0;
            realtimeProcessor.onaudioprocess = (e) => {
                if (!realtimeWs || realtimeWs.readyState !== WebSocket.OPEN) {
                    console.log('WebSocketæœªå°±ç»ªï¼Œè·³è¿‡å‘é€');
                    return;
                }

                const inputData = e.inputBuffer.getChannelData(0);
                // è½¬æ¢ä¸º 16bit PCM
                const pcmData = new Int16Array(inputData.length);
                for (let i = 0; i < inputData.length; i++) {
                    pcmData[i] = Math.max(-32768, Math.min(32767, inputData[i] * 32768));
                }

                // å‘é€éŸ³é¢‘æ•°æ®
                realtimeWs.send(pcmData.buffer);
                chunkCount++;
                if (chunkCount % 10 === 0) {
                    console.log(`å·²å‘é€ ${chunkCount} ä¸ªéŸ³é¢‘å—`);
                }
            };

            source.connect(realtimeProcessor);
            realtimeProcessor.connect(realtimeContext.destination);
            console.log('éŸ³é¢‘æ•è·å·²å¯åŠ¨');
        }

        function stopRealtime() {
            const btn = document.getElementById('realtimeBtn');

            // å…³é—­ WebSocket
            if (realtimeWs) {
                realtimeWs.close();
                realtimeWs = null;
            }

            // åœæ­¢éŸ³é¢‘å¤„ç†
            if (realtimeProcessor) {
                realtimeProcessor.disconnect();
                realtimeProcessor = null;
            }

            if (realtimeContext) {
                realtimeContext.close();
                realtimeContext = null;
            }

            // åœæ­¢éº¦å…‹é£
            if (realtimeStream) {
                realtimeStream.getTracks().forEach(track => track.stop());
                realtimeStream = null;
            }

            // åœæ­¢è®¡æ—¶å™¨
            if (realtimeTimer) {
                clearInterval(realtimeTimer);
                realtimeTimer = null;
            }

            // æ›´æ–°UI
            isRealtimeRunning = false;
            btn.textContent = 'âš¡ å¼€å§‹å®æ—¶è¯†åˆ«';
            btn.className = 'success';
            btn.style.background = '';
        }

        function setupRealtimeVisualizer(stream) {
            const canvas = document.getElementById('realtimeVisualizer');
            const ctx = canvas.getContext('2d');
            const audioCtx = new AudioContext();
            const analyser = audioCtx.createAnalyser();
            audioCtx.createMediaStreamSource(stream).connect(analyser);
            analyser.fftSize = 256;
            const dataArray = new Uint8Array(analyser.frequencyBinCount);

            function draw() {
                if (!isRealtimeRunning) return;
                requestAnimationFrame(draw);
                analyser.getByteFrequencyData(dataArray);
                ctx.fillStyle = '#f0f0f0';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                const barWidth = (canvas.width / dataArray.length) * 2.5;
                let x = 0;
                for (let i = 0; i < dataArray.length; i++) {
                    ctx.fillStyle = `rgb(40, ${167 + dataArray[i] / 3}, 69)`;
                    ctx.fillRect(x, canvas.height - (dataArray[i] / 255) * canvas.height, barWidth, (dataArray[i] / 255) * canvas.height);
                    x += barWidth + 1;
                }
            }
            draw();
        }

        // ========== ç”µå­ç—…å†ç”Ÿæˆ ==========
        function getPatientInfo() {
            return {
                name: document.getElementById('patientName').value.trim(),
                gender: document.getElementById('patientGender').value,
                age: document.getElementById('patientAge').value
            };
        }

        async function generateMedicalRecordFromFile() {
            const config = getConfig();
            let audioData;
            // ä½¿ç”¨conversationçš„éŸ³é¢‘æ•°æ®
            if (currentConversationMode === 'file') {
                audioData = convertedAudio['conversation'];
            } else if (currentConversationMode === 'record') {
                audioData = recorders['conversation'].blob || convertedAudio['conversation'];
            }

            // è·å–æ‚£è€…ä¿¡æ¯
            const patientInfo = getPatientInfo();

            if (!audioData) {
                alert('è¯·é€‰æ‹©éŸ³é¢‘æ–‡ä»¶æˆ–å½•åˆ¶å£°éŸ³');
                return;
            }

            const formData = new FormData();
            formData.append('file', audioData, 'audio.wav');
            formData.append('speaker_ids', '');
            // æ·»åŠ æ‚£è€…åŸºæœ¬ä¿¡æ¯
            formData.append('patient_name', patientInfo.name);
            formData.append('patient_gender', patientInfo.gender);
            formData.append('patient_age', patientInfo.age);

            // è·å–å¯¹åº”çš„æŒ‰é’®
            const btn = currentConversationMode === 'file'
                ? document.getElementById('conversationFileMedicalBtn')
                : document.getElementById('conversationRecordMedicalBtn');
            btn.disabled = true;
            btn.textContent = 'â³ æ­£åœ¨åˆ†æ...';

            try {
                const response = await fetch(`${config.apiUrl}/voiceprint/medical-record`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${config.apiToken}` },
                    body: formData
                });
                const data = await response.json();
                // æŠŠæ‚£è€…ä¿¡æ¯åŠ åˆ°è¿”å›æ•°æ®ä¸­
                data.patient_basic = patientInfo;
                displayMedicalRecord(data, 'conversationResult');
            } catch (error) {
                showResult('conversationResult', { error: error.message }, false);
            } finally {
                btn.disabled = false;
                btn.textContent = 'ğŸ“‹ ç”Ÿæˆç”µå­ç—…å†';
            }
        }

        async function generateMedicalRecordFromRealtime() {
            if (realtimeConversation.length === 0) {
                alert('æ²¡æœ‰å¯¹è¯è®°å½•ï¼Œè¯·å…ˆè¿›è¡Œå®æ—¶è¯†åˆ«');
                return;
            }

            const config = getConfig();
            const btn = document.getElementById('generateRecordBtn');
            btn.disabled = true;
            btn.textContent = 'â³ æ­£åœ¨ç”Ÿæˆç—…å†...';

            try {
                const response = await fetch(`${config.apiUrl}/voiceprint/analyze-conversation`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${config.apiToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(realtimeConversation)
                });
                const data = await response.json();

                // æ˜¾ç¤ºåœ¨å¯¹è¯ç»“æœåŒºåŸŸ
                displayMedicalRecord({
                    success: data.success,
                    conversation: realtimeConversation,
                    medical_record: data.medical_record,
                    raw_response: data.raw_response,
                    error: data.error
                }, 'conversationResult');
            } catch (error) {
                showResult('conversationResult', { error: error.message }, false);
            } finally {
                btn.disabled = false;
                btn.textContent = 'ğŸ“‹ ç”Ÿæˆç”µå­ç—…å†';
            }
        }

        // å½“å‰æ˜¾ç¤ºçš„ç—…å†æ•°æ®ï¼ˆç”¨äºç¼–è¾‘ï¼‰
        let currentMedicalData = null;
        let isEditMode = false;

        function displayMedicalRecord(data, elementId) {
            // å¦‚æœå¤±è´¥ï¼Œåœ¨åŸä½ç½®æ˜¾ç¤ºé”™è¯¯
            if (!data.success) {
                if (elementId) {
                    const el = document.getElementById(elementId);
                    el.style.display = 'block';
                    el.className = 'result error';
                    el.innerHTML = `<strong>âŒ ç”Ÿæˆå¤±è´¥</strong><br>${data.error || 'æœªçŸ¥é”™è¯¯'}`;
                }
                return;
            }

            // ä¿å­˜å½“å‰æ•°æ®ç”¨äºç¼–è¾‘
            currentMedicalData = data;
            isEditMode = false;
            document.getElementById('editMedicalBtn').textContent = 'âœï¸ ç¼–è¾‘';

            renderMedicalRecord(data);
            document.getElementById('medicalModal').classList.add('active');
        }

        function renderMedicalRecord(data) {
            let html = '';

            // æ‚£è€…åŸºæœ¬ä¿¡æ¯
            if (data.patient_basic && (data.patient_basic.name || data.patient_basic.gender || data.patient_basic.age)) {
                html += '<div style="background:#e3f2fd;padding:12px 16px;border-radius:8px;margin-bottom:16px;display:flex;gap:20px;flex-wrap:wrap;">';
                if (data.patient_basic.name) {
                    html += `<span><strong>å§“åï¼š</strong><span class="editable-field" data-field="patient_basic.name">${data.patient_basic.name}</span></span>`;
                }
                if (data.patient_basic.gender) {
                    html += `<span><strong>æ€§åˆ«ï¼š</strong><span class="editable-field" data-field="patient_basic.gender">${data.patient_basic.gender}</span></span>`;
                }
                if (data.patient_basic.age) {
                    html += `<span><strong>å¹´é¾„ï¼š</strong><span class="editable-field" data-field="patient_basic.age">${data.patient_basic.age}</span>å²</span>`;
                }
                html += '</div>';
            }

            // å¯¹è¯è®°å½•é¢„è§ˆ
            if (data.conversation && data.conversation.length > 0) {
                html += '<div class="conversation-preview">';
                html += '<strong style="color:#666;font-size:13px;">ğŸ“ å¯¹è¯è®°å½•ï¼š</strong><br>';
                // è·å–æ‚£è€…å§“åï¼Œç”¨äºæ˜¾ç¤º
                const patientDisplayName = (data.patient_basic && data.patient_basic.name) ? data.patient_basic.name : 'æ‚£è€…/å®¶å±';
                data.conversation.forEach(seg => {
                    // åŒ»ç”Ÿæ˜¾ç¤ºå£°çº¹IDï¼Œæ‚£è€…æ˜¾ç¤ºæ‚£è€…å§“å
                    const role = seg.speaker_id ? seg.speaker_id : patientDisplayName;
                    const roleColor = seg.speaker_id ? '#28a745' : '#fd7e14';
                    if (seg.text) {
                        html += `<div style="margin:4px 0;"><span style="color:${roleColor};font-weight:600;">[${role}]</span> ${seg.text}</div>`;
                    }
                });
                html += '</div>';
            }

            // ç”µå­ç—…å†
            if (data.medical_record) {
                const record = data.medical_record;

                // åˆ¤æ–­æ˜¯å¦æœ‰å®é™…å†…å®¹ï¼ˆæ’é™¤"æœªæåŠ"ã€"å¯¹è¯ä¸­æœªæåŠ"ç­‰ï¼‰
                function hasContent(val) {
                    if (!val) return false;
                    const empty = ['æœªæåŠ', 'å¯¹è¯ä¸­æœªæåŠ', 'æ— ', 'æš‚æ— ', '-'];
                    return !empty.includes(val.trim());
                }

                // æ‚£è€…ç—…æƒ…ä¿¡æ¯
                if (record.patient_info) {
                    let patientHtml = '';
                    if (hasContent(record.patient_info.chief_complaint)) {
                        patientHtml += `<div class="medical-item"><strong>ä¸»è¯‰ï¼š</strong><span class="editable-field" data-field="medical_record.patient_info.chief_complaint">${record.patient_info.chief_complaint}</span></div>`;
                    }
                    if (hasContent(record.patient_info.present_illness)) {
                        patientHtml += `<div class="medical-item"><strong>ç°ç—…å²ï¼š</strong><span class="editable-field" data-field="medical_record.patient_info.present_illness">${record.patient_info.present_illness}</span></div>`;
                    }
                    if (hasContent(record.patient_info.past_history)) {
                        patientHtml += `<div class="medical-item"><strong>æ—¢å¾€å²ï¼š</strong><span class="editable-field" data-field="medical_record.patient_info.past_history">${record.patient_info.past_history}</span></div>`;
                    }
                    if (hasContent(record.patient_info.personal_history)) {
                        patientHtml += `<div class="medical-item"><strong>ä¸ªäººå²ï¼š</strong><span class="editable-field" data-field="medical_record.patient_info.personal_history">${record.patient_info.personal_history}</span></div>`;
                    }
                    if (patientHtml) {
                        html += '<div class="medical-section patient">';
                        html += '<h4>ğŸ‘¤ æ‚£è€…ç—…æƒ…</h4>';
                        html += patientHtml;
                        html += '</div>';
                    }
                }

                // åŒ»ç”Ÿè¯„ä¼°
                if (record.doctor_assessment) {
                    let doctorHtml = '';
                    if (hasContent(record.doctor_assessment.physical_exam)) {
                        doctorHtml += `<div class="medical-item"><strong>ä½“æ ¼æ£€æŸ¥ï¼š</strong><span class="editable-field" data-field="medical_record.doctor_assessment.physical_exam">${record.doctor_assessment.physical_exam}</span></div>`;
                    }
                    if (hasContent(record.doctor_assessment.preliminary_diagnosis)) {
                        doctorHtml += `<div class="medical-item"><strong>åˆæ­¥è¯Šæ–­ï¼š</strong><span class="editable-field" data-field="medical_record.doctor_assessment.preliminary_diagnosis">${record.doctor_assessment.preliminary_diagnosis}</span></div>`;
                    }
                    if (hasContent(record.doctor_assessment.differential_diagnosis)) {
                        doctorHtml += `<div class="medical-item"><strong>é‰´åˆ«è¯Šæ–­ï¼š</strong><span class="editable-field" data-field="medical_record.doctor_assessment.differential_diagnosis">${record.doctor_assessment.differential_diagnosis}</span></div>`;
                    }
                    if (hasContent(record.doctor_assessment.treatment_plan)) {
                        doctorHtml += `<div class="medical-item"><strong>æ²»ç–—æ–¹æ¡ˆï¼š</strong><span class="editable-field" data-field="medical_record.doctor_assessment.treatment_plan">${record.doctor_assessment.treatment_plan}</span></div>`;
                    }
                    if (hasContent(record.doctor_assessment.follow_up)) {
                        doctorHtml += `<div class="medical-item"><strong>éšè®¿å»ºè®®ï¼š</strong><span class="editable-field" data-field="medical_record.doctor_assessment.follow_up">${record.doctor_assessment.follow_up}</span></div>`;
                    }
                    if (doctorHtml) {
                        html += '<div class="medical-section doctor">';
                        html += '<h4>ğŸ©º åŒ»ç”Ÿè¯„ä¼°</h4>';
                        html += doctorHtml;
                        html += '</div>';
                    }
                }

                // æ‘˜è¦
                if (record.summary) {
                    html += `<div class="medical-summary"><strong>ğŸ“Œ ç—…å†æ‘˜è¦ï¼š</strong><span class="editable-field" data-field="medical_record.summary">${record.summary}</span></div>`;
                }
            } else if (data.raw_response) {
                html += '<div class="medical-section" style="border-left-color:#fd7e14;">';
                html += '<h4>âš ï¸ å¤§æ¨¡å‹åŸå§‹å“åº”</h4>';
                html += `<pre style="white-space:pre-wrap;font-size:13px;background:#fff;padding:10px;border-radius:6px;">${data.raw_response}</pre>`;
                html += '</div>';
            }

            document.getElementById('medicalModalBody').innerHTML = html;
        }

        function toggleEditMode() {
            if (!currentMedicalData) return;

            isEditMode = !isEditMode;
            const btn = document.getElementById('editMedicalBtn');
            const fields = document.querySelectorAll('.editable-field');

            if (isEditMode) {
                btn.textContent = 'ğŸ’¾ ä¿å­˜';
                btn.style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';

                // å°†å­—æ®µå˜ä¸ºå¯ç¼–è¾‘
                fields.forEach(field => {
                    field.contentEditable = true;
                    field.style.background = '#fff';
                    field.style.padding = '4px 8px';
                    field.style.borderRadius = '4px';
                    field.style.border = '1px solid #667eea';
                    field.style.minWidth = '100px';
                    field.style.display = 'inline-block';
                });
            } else {
                btn.textContent = 'âœï¸ ç¼–è¾‘';
                btn.style.background = 'rgba(255,255,255,0.2)';

                // ä¿å­˜ä¿®æ”¹
                fields.forEach(field => {
                    const fieldPath = field.dataset.field;
                    const value = field.textContent.trim();
                    setNestedValue(currentMedicalData, fieldPath, value);

                    field.contentEditable = false;
                    field.style.background = '';
                    field.style.padding = '';
                    field.style.border = '';
                    field.style.minWidth = '';
                });

                // å¦‚æœæœ‰ record_idï¼Œä¿å­˜åˆ°æœåŠ¡å™¨
                if (currentMedicalData.record_id) {
                    saveMedicalRecordToServer(currentMedicalData);
                }
            }
        }

        function setNestedValue(obj, path, value) {
            const keys = path.split('.');
            let current = obj;
            for (let i = 0; i < keys.length - 1; i++) {
                if (!current[keys[i]]) current[keys[i]] = {};
                current = current[keys[i]];
            }
            current[keys[keys.length - 1]] = value;
        }

        async function saveMedicalRecordToServer(data) {
            const config = getConfig();
            try {
                const response = await fetch(`${config.apiUrl}/voiceprint/medical-records/${data.record_id}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${config.apiToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        patient_name: data.patient_basic?.name || '',
                        patient_gender: data.patient_basic?.gender || '',
                        patient_age: data.patient_basic?.age || '',
                        medical_record: data.medical_record
                    })
                });
                const result = await response.json();
                if (result.success) {
                    console.log('ç—…å†ä¿å­˜æˆåŠŸ');
                } else {
                    alert('ä¿å­˜å¤±è´¥: ' + (result.error || 'æœªçŸ¥é”™è¯¯'));
                }
            } catch (error) {
                console.error('ä¿å­˜ç—…å†å¤±è´¥:', error);
            }
        }

        async function exportPdf() {
            if (!currentMedicalData || !currentMedicalData.record_id) {
                alert('å½“å‰ç—…å†æœªä¿å­˜ï¼Œæ— æ³•å¯¼å‡º PDF');
                return;
            }

            const config = getConfig();
            const btn = document.getElementById('exportPdfBtn');
            btn.disabled = true;
            btn.textContent = 'â³ å¯¼å‡ºä¸­...';

            try {
                const response = await fetch(`${config.apiUrl}/voiceprint/medical-records/${currentMedicalData.record_id}/pdf`, {
                    headers: { 'Authorization': `Bearer ${config.apiToken}` }
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'å¯¼å‡ºå¤±è´¥');
                }

                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ç—…å†_${currentMedicalData.record_id}.pdf`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
            } catch (error) {
                alert('å¯¼å‡º PDF å¤±è´¥: ' + error.message);
            } finally {
                btn.disabled = false;
                btn.textContent = 'ğŸ“„ å¯¼å‡ºPDF';
            }
        }

        function closeMedicalModal(event) {
            if (!event || event.target === document.getElementById('medicalModal')) {
                document.getElementById('medicalModal').classList.remove('active');
            }
        }

        // ESC é”®å…³é—­å¼¹çª—
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeMedicalModal();
                closeHistoryModal();
            }
        });

        // ========== å†å²è®°å½•åŠŸèƒ½ ==========
        async function showMedicalHistory() {
            const config = getConfig();
            document.getElementById('historyModal').classList.add('active');
            document.getElementById('historyModalBody').innerHTML = '<div style="text-align:center;padding:40px;color:#666;">â³ åŠ è½½ä¸­...</div>';

            try {
                const response = await fetch(`${config.apiUrl}/voiceprint/medical-records`, {
                    headers: { 'Authorization': `Bearer ${config.apiToken}` }
                });
                const data = await response.json();

                if (data.success && data.records) {
                    if (data.records.length === 0) {
                        document.getElementById('historyModalBody').innerHTML = '<div style="text-align:center;padding:40px;color:#666;">æš‚æ— ç—…å†è®°å½•</div>';
                        return;
                    }

                    let html = `<div style="margin-bottom:16px;color:#666;">å…± ${data.total} æ¡è®°å½•</div>`;
                    html += '<div style="display:flex;flex-direction:column;gap:12px;">';

                    data.records.forEach(record => {
                        const genderIcon = record.patient_gender === 'ç”·' ? 'ğŸ‘¨' : (record.patient_gender === 'å¥³' ? 'ğŸ‘©' : 'ğŸ‘¤');
                        html += `
                        <div style="background:#f8f9fa;border-radius:12px;padding:16px;border:1px solid #e0e0e0;cursor:pointer;transition:all 0.2s;" 
                             onmouseover="this.style.boxShadow='0 4px 12px rgba(0,0,0,0.1)';this.style.borderColor='#667eea';"
                             onmouseout="this.style.boxShadow='none';this.style.borderColor='#e0e0e0';"
                             onclick="viewMedicalRecord('${record.record_id}')">
                            <div style="display:flex;justify-content:space-between;align-items:flex-start;">
                                <div style="flex:1;">
                                    <div style="font-size:16px;font-weight:600;color:#333;margin-bottom:6px;">
                                        ${genderIcon} ${record.patient_name || 'æœªçŸ¥æ‚£è€…'}
                                        ${record.patient_gender ? `<span style="color:#666;font-weight:normal;font-size:14px;margin-left:8px;">${record.patient_gender}</span>` : ''}
                                        ${record.patient_age ? `<span style="color:#666;font-weight:normal;font-size:14px;margin-left:8px;">${record.patient_age}å²</span>` : ''}
                                    </div>
                                    ${record.summary ? `<div style="color:#666;font-size:13px;line-height:1.5;margin-top:8px;">${record.summary}</div>` : ''}
                                </div>
                                <div style="display:flex;flex-direction:column;align-items:flex-end;gap:8px;">
                                    <span style="color:#999;font-size:12px;">${record.created_at}</span>
                                    <button onclick="event.stopPropagation();deleteMedicalRecord('${record.record_id}')" 
                                            style="background:#dc3545;padding:4px 10px;font-size:12px;margin:0;">ğŸ—‘ï¸ åˆ é™¤</button>
                                </div>
                            </div>
                        </div>`;
                    });

                    html += '</div>';
                    document.getElementById('historyModalBody').innerHTML = html;
                } else {
                    document.getElementById('historyModalBody').innerHTML = `<div style="text-align:center;padding:40px;color:#dc3545;">åŠ è½½å¤±è´¥: ${data.error || 'æœªçŸ¥é”™è¯¯'}</div>`;
                }
            } catch (error) {
                document.getElementById('historyModalBody').innerHTML = `<div style="text-align:center;padding:40px;color:#dc3545;">åŠ è½½å¤±è´¥: ${error.message}</div>`;
            }
        }

        async function viewMedicalRecord(recordId) {
            const config = getConfig();
            try {
                const response = await fetch(`${config.apiUrl}/voiceprint/medical-records/${recordId}`, {
                    headers: { 'Authorization': `Bearer ${config.apiToken}` }
                });
                const data = await response.json();

                if (data.success && data.record) {
                    // å…³é—­å†å²å¼¹çª—ï¼Œæ‰“å¼€ç—…å†è¯¦æƒ…å¼¹çª—
                    closeHistoryModal();
                    displayMedicalRecord({
                        success: true,
                        conversation: data.record.conversation,
                        medical_record: data.record.medical_record,
                        patient_basic: {
                            name: data.record.patient_name,
                            gender: data.record.patient_gender,
                            age: data.record.patient_age
                        }
                    }, null);
                } else {
                    alert('åŠ è½½ç—…å†å¤±è´¥: ' + (data.error || 'æœªçŸ¥é”™è¯¯'));
                }
            } catch (error) {
                alert('åŠ è½½ç—…å†å¤±è´¥: ' + error.message);
            }
        }

        async function deleteMedicalRecord(recordId) {
            if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡ç—…å†å—ï¼Ÿ')) return;

            const config = getConfig();
            try {
                const response = await fetch(`${config.apiUrl}/voiceprint/medical-records/${recordId}`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `Bearer ${config.apiToken}` }
                });
                const data = await response.json();

                if (data.success) {
                    // åˆ·æ–°åˆ—è¡¨
                    showMedicalHistory();
                } else {
                    alert('åˆ é™¤å¤±è´¥: ' + (data.error || 'æœªçŸ¥é”™è¯¯'));
                }
            } catch (error) {
                alert('åˆ é™¤å¤±è´¥: ' + error.message);
            }
        }

        function closeHistoryModal(event) {
            if (!event || event.target === document.getElementById('historyModal')) {
                document.getElementById('historyModal').classList.remove('active');
            }
        }

        window.onload = () => checkHealth();
    </script>
</body>

</html>