<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å£°çº¹è¯†åˆ«æµ‹è¯•é¡µé¢</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }

        h1 {
            color: white;
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .card {
            background: white;
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        }

        .card h2 {
            color: #333;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }

        .form-group {
            margin-bottom: 16px;
        }

        label {
            display: block;
            margin-bottom: 6px;
            color: #555;
            font-weight: 500;
        }

        input[type="text"],
        input[type="file"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 14px 28px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            margin-right: 10px;
            margin-top: 10px;
            transition: transform 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        button.secondary {
            background: #6c757d;
        }

        button.recording {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.7;
            }
        }

        .result {
            margin-top: 20px;
            padding: 16px;
            border-radius: 8px;
            background: #f8f9fa;
            border-left: 4px solid #667eea;
        }

        .result.success {
            border-left-color: #28a745;
            background: #d4edda;
        }

        .result.error {
            border-left-color: #dc3545;
            background: #f8d7da;
        }

        .result pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 13px;
        }

        .config-section {
            background: #f8f9fa;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .status {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
        }

        .status.online {
            background: #d4edda;
            color: #155724;
        }

        .status.offline {
            background: #f8d7da;
            color: #721c24;
        }

        .audio-player {
            margin-top: 10px;
            width: 100%;
        }

        .audio-source-tabs {
            display: flex;
            margin-bottom: 16px;
            border-bottom: 2px solid #e0e0e0;
        }

        .tab-btn {
            background: none;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            color: #666;
            font-size: 14px;
            border-bottom: 2px solid transparent;
            margin-bottom: -2px;
            margin-right: 0;
            margin-top: 0;
        }

        .tab-btn.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }

        .tab-btn:hover {
            color: #667eea;
            transform: none;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .record-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .record-time {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
            min-width: 80px;
        }

        .visualizer {
            width: 100%;
            height: 60px;
            background: #f0f0f0;
            border-radius: 8px;
            margin-top: 10px;
        }

        .audio-info {
            margin-top: 10px;
            padding: 10px;
            background: #e9ecef;
            border-radius: 6px;
            font-size: 13px;
            color: #495057;
        }

        .converting {
            color: #667eea;
            font-style: italic;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>ğŸ¤ å£°çº¹è¯†åˆ«æµ‹è¯•é¡µé¢</h1>

        <!-- é…ç½®åŒºåŸŸ -->
        <div class="card">
            <h2>âš™ï¸ æœåŠ¡é…ç½®</h2>
            <div class="config-section">
                <div class="form-group">
                    <label>API åœ°å€</label>
                    <input type="text" id="apiUrl" value="http://192.168.0.207:8520">
                </div>
                <div class="form-group">
                    <label>API Token</label>
                    <input type="text" id="apiToken" value="b5c31ad0-4ac6-4476-b04f-aec9397420a1">
                </div>
                <button onclick="checkHealth()">æ£€æŸ¥æœåŠ¡çŠ¶æ€</button>
                <span id="serviceStatus" class="status offline">æœªæ£€æµ‹</span>
            </div>
            <div class="result" id="healthResult" style="display:none;"></div>
        </div>

        <!-- å£°çº¹æ³¨å†Œ -->
        <div class="card">
            <h2>ğŸ“ å£°çº¹æ³¨å†Œ</h2>
            <p style="color:#666; margin-bottom:16px;">ä¸Šä¼ éŸ³é¢‘æˆ–å½•åˆ¶å£°éŸ³ï¼Œæ³¨å†Œå£°çº¹ç‰¹å¾</p>
            <div class="form-group">
                <label>è¯´è¯äºº ID</label>
                <input type="text" id="registerSpeakerId" placeholder="ä¾‹å¦‚: zhangsan">
            </div>
            <div class="audio-source-tabs">
                <button class="tab-btn active" onclick="switchTab('register', 'file', this)">ğŸ“ ä¸Šä¼ æ–‡ä»¶</button>
                <button class="tab-btn" onclick="switchTab('register', 'mic', this)">ğŸ™ï¸ éº¦å…‹é£å½•éŸ³</button>
            </div>
            <div id="register-file-tab" class="tab-content active">
                <div class="form-group">
                    <label>éŸ³é¢‘æ–‡ä»¶</label>
                    <input type="file" id="registerAudioFile" accept="audio/*"
                        onchange="handleFileSelect(this, 'register')">
                    <div id="registerFileInfo" class="audio-info" style="display:none;"></div>
                    <audio id="registerFilePlayer" class="audio-player" controls style="display:none;"></audio>
                </div>
            </div>
            <div id="register-mic-tab" class="tab-content">
                <div class="record-controls">
                    <button id="registerRecordBtn" onclick="toggleRecording('register')">ğŸ™ï¸ å¼€å§‹å½•éŸ³</button>
                    <span class="record-time" id="registerRecordTime">00:00</span>
                </div>
                <canvas id="registerVisualizer" class="visualizer"></canvas>
                <audio id="registerMicPlayer" class="audio-player" controls style="display:none;"></audio>
            </div>
            <button onclick="registerVoiceprint()">æ³¨å†Œå£°çº¹</button>
            <div class="result" id="registerResult" style="display:none;"></div>
        </div>

        <!-- å£°çº¹è¯†åˆ« -->
        <div class="card">
            <h2>ğŸ” å£°çº¹è¯†åˆ«</h2>
            <p style="color:#666; margin-bottom:16px;">ä¸Šä¼ éŸ³é¢‘æˆ–å½•åˆ¶å£°éŸ³ï¼Œè¯†åˆ«è¯´è¯äººèº«ä»½</p>
            <div class="form-group">
                <label>å€™é€‰è¯´è¯äºº IDï¼ˆç•™ç©ºè‡ªåŠ¨åŒ¹é…æ‰€æœ‰ï¼Œå¤šä¸ªç”¨é€—å·åˆ†éš”ï¼‰</label>
                <input type="text" id="identifySpeakerIds" placeholder="ç•™ç©ºè‡ªåŠ¨åŒ¹é…æ‰€æœ‰å·²æ³¨å†Œå£°çº¹">
            </div>
            <div class="audio-source-tabs">
                <button class="tab-btn active" onclick="switchTab('identify', 'file', this)">ğŸ“ ä¸Šä¼ æ–‡ä»¶</button>
                <button class="tab-btn" onclick="switchTab('identify', 'mic', this)">ğŸ™ï¸ éº¦å…‹é£å½•éŸ³</button>
            </div>
            <div id="identify-file-tab" class="tab-content active">
                <div class="form-group">
                    <label>éŸ³é¢‘æ–‡ä»¶</label>
                    <input type="file" id="identifyAudioFile" accept="audio/*"
                        onchange="handleFileSelect(this, 'identify')">
                    <div id="identifyFileInfo" class="audio-info" style="display:none;"></div>
                    <audio id="identifyFilePlayer" class="audio-player" controls style="display:none;"></audio>
                </div>
            </div>
            <div id="identify-mic-tab" class="tab-content">
                <div class="record-controls">
                    <button id="identifyRecordBtn" onclick="toggleRecording('identify')">ğŸ™ï¸ å¼€å§‹å½•éŸ³</button>
                    <span class="record-time" id="identifyRecordTime">00:00</span>
                </div>
                <canvas id="identifyVisualizer" class="visualizer"></canvas>
                <audio id="identifyMicPlayer" class="audio-player" controls style="display:none;"></audio>
            </div>
            <button onclick="identifyVoiceprint()">è¯†åˆ«å£°çº¹</button>
            <div class="result" id="identifyResult" style="display:none;"></div>
        </div>

        <!-- å¤šäººå¯¹è¯è¯†åˆ« -->
        <div class="card">
            <h2>ğŸ¥ å¤šäººå¯¹è¯è¯†åˆ«</h2>
            <p style="color:#666; margin-bottom:16px;">é€‚ç”¨äºåŒ»ç”Ÿ-æ‚£è€…ç­‰å¤šäººå¯¹è¯åœºæ™¯ï¼Œè‡ªåŠ¨è¯†åˆ«è¯´è¯äººèº«ä»½å¹¶è½¬å†™å¯¹è¯å†…å®¹</p>
            <div style="background:#e7f3ff; padding:12px; border-radius:8px; margin-bottom:16px; font-size:13px;">
                <strong>ğŸ’¡ ä½¿ç”¨è¯´æ˜ï¼š</strong><br>
                1. å…ˆåœ¨ä¸Šæ–¹"å£°çº¹æ³¨å†Œ"ä¸­æ³¨å†Œå„è¯´è¯äººçš„å£°çº¹<br>
                2. é€‰æ‹©è¯†åˆ«æ¨¡å¼ï¼šä¸Šä¼ æ–‡ä»¶/å½•éŸ³ æˆ– å®æ—¶è¯†åˆ«<br>
                3. ç•™ç©ºå°†è‡ªåŠ¨åŒ¹é…æ•°æ®åº“ä¸­æ‰€æœ‰å·²æ³¨å†Œå£°çº¹
            </div>
            <div class="form-group">
                <label>å€™é€‰è¯´è¯äºº IDï¼ˆç•™ç©ºè‡ªåŠ¨åŒ¹é…æ‰€æœ‰ï¼‰</label>
                <input type="text" id="conversationSpeakerIds" placeholder="ç•™ç©ºè‡ªåŠ¨åŒ¹é…æ‰€æœ‰å·²æ³¨å†Œå£°çº¹">
            </div>

            <!-- æ¨¡å¼é€‰æ‹© -->
            <div class="audio-source-tabs" style="margin-bottom:16px;">
                <button class="tab-btn active" onclick="switchConversationMode('file', this)">ğŸ“ ä¸Šä¼ æ–‡ä»¶</button>
                <button class="tab-btn" onclick="switchConversationMode('record', this)">ğŸ™ï¸ å½•éŸ³è¯†åˆ«</button>
                <button class="tab-btn" onclick="switchConversationMode('realtime', this)">âš¡ å®æ—¶è¯†åˆ«</button>
            </div>

            <!-- ä¸Šä¼ æ–‡ä»¶æ¨¡å¼ -->
            <div id="conversation-file-mode" class="tab-content active">
                <div class="form-group">
                    <label>éŸ³é¢‘æ–‡ä»¶</label>
                    <input type="file" id="conversationAudioFile" accept="audio/*"
                        onchange="handleFileSelect(this, 'conversation')">
                    <div id="conversationFileInfo" class="audio-info" style="display:none;"></div>
                    <audio id="conversationFilePlayer" class="audio-player" controls style="display:none;"></audio>
                </div>
                <button id="conversationFileBtn" onclick="conversationRecognize()">ğŸ¯ è¯†åˆ«å¯¹è¯</button>
            </div>

            <!-- å½•éŸ³æ¨¡å¼ -->
            <div id="conversation-record-mode" class="tab-content">
                <div class="record-controls">
                    <button id="conversationRecordBtn" onclick="toggleRecording('conversation')">ğŸ™ï¸ å¼€å§‹å½•éŸ³</button>
                    <span class="record-time" id="conversationRecordTime">00:00</span>
                </div>
                <canvas id="conversationVisualizer" class="visualizer"></canvas>
                <audio id="conversationMicPlayer" class="audio-player" controls style="display:none;"></audio>
                <button id="conversationRecordSubmitBtn" onclick="conversationRecognize()" style="margin-top:10px;">ğŸ¯
                    è¯†åˆ«å½•éŸ³</button>
            </div>

            <!-- å®æ—¶è¯†åˆ«æ¨¡å¼ -->
            <div id="conversation-realtime-mode" class="tab-content">
                <div class="record-controls">
                    <button id="realtimeBtn" onclick="toggleRealtime()"
                        style="background: linear-gradient(135deg, #28a745 0%, #20c997 100%);">âš¡ å¼€å§‹å®æ—¶è¯†åˆ«</button>
                    <span class="record-time" id="realtimeTime">00:00</span>
                    <span id="realtimeStatus" style="color:#666;margin-left:10px;">æœªè¿æ¥</span>
                </div>
                <canvas id="realtimeVisualizer" class="visualizer"></canvas>
                <div id="realtimeMessages"
                    style="font-size:14px; line-height:1.8; min-height:100px; max-height:300px; overflow-y:auto; background:#f8f9fa; padding:10px; border-radius:8px; margin-top:10px;">
                </div>
            </div>

            <!-- è¯†åˆ«ç»“æœ -->
            <div class="result" id="conversationResult" style="display:none;"></div>
        </div>

        <!-- å£°çº¹ç®¡ç† -->
        <div class="card">
            <h2>ğŸ—‘ï¸ å£°çº¹ç®¡ç†</h2>
            <div class="form-group">
                <label>è¯´è¯äºº ID</label>
                <input type="text" id="deleteSpeakerId" placeholder="ä¾‹å¦‚: zhangsan">
            </div>
            <button onclick="deleteVoiceprint()">åˆ é™¤å£°çº¹</button>
            <button class="secondary" onclick="listVoiceprints()">æŸ¥çœ‹æ‰€æœ‰å£°çº¹</button>
            <div class="result" id="deleteResult" style="display:none;"></div>
        </div>
    </div>

    <script>
        const TARGET_SAMPLE_RATE = 16000;
        const recorders = {
            register: { mediaRecorder: null, audioChunks: [], blob: null, isRecording: false, timer: null, seconds: 0 },
            identify: { mediaRecorder: null, audioChunks: [], blob: null, isRecording: false, timer: null, seconds: 0 },
            diarize: { mediaRecorder: null, audioChunks: [], blob: null, isRecording: false, timer: null, seconds: 0 },
            conversation: { mediaRecorder: null, audioChunks: [], blob: null, isRecording: false, timer: null, seconds: 0 }
        };
        const convertedAudio = { register: null, identify: null, diarize: null, conversation: null };
        const activeTab = { register: 'file', identify: 'file', diarize: 'file', conversation: 'file' };

        function switchTab(section, tab, btn) {
            activeTab[section] = tab;
            document.getElementById(`${section}-file-tab`).classList.toggle('active', tab === 'file');
            document.getElementById(`${section}-mic-tab`).classList.toggle('active', tab === 'mic');
            btn.parentElement.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
        }

        let currentConversationMode = 'file';
        function switchConversationMode(mode, btn) {
            currentConversationMode = mode;
            document.getElementById('conversation-file-mode').classList.toggle('active', mode === 'file');
            document.getElementById('conversation-record-mode').classList.toggle('active', mode === 'record');
            document.getElementById('conversation-realtime-mode').classList.toggle('active', mode === 'realtime');
            btn.parentElement.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            // å¦‚æœåˆ‡æ¢åˆ°å…¶ä»–æ¨¡å¼ï¼Œåœæ­¢å®æ—¶è¯†åˆ«
            if (mode !== 'realtime' && isRealtimeRunning) {
                stopRealtime();
            }
        }

        async function handleFileSelect(input, section) {
            const file = input.files[0];
            if (!file) return;
            const infoEl = document.getElementById(`${section}FileInfo`);
            const playerEl = document.getElementById(`${section}FilePlayer`);
            infoEl.style.display = 'block';
            infoEl.innerHTML = '<span class="converting">â³ æ­£åœ¨è½¬æ¢éŸ³é¢‘æ ¼å¼...</span>';
            try {
                const audioContext = new AudioContext({ sampleRate: TARGET_SAMPLE_RATE });
                const arrayBuffer = await file.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                const offlineContext = new OfflineAudioContext(1, audioBuffer.duration * TARGET_SAMPLE_RATE, TARGET_SAMPLE_RATE);
                const source = offlineContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(offlineContext.destination);
                source.start();
                const renderedBuffer = await offlineContext.startRendering();
                const wavBlob = audioBufferToWav(renderedBuffer);
                convertedAudio[section] = wavBlob;
                infoEl.innerHTML = `âœ… è½¬æ¢å®Œæˆ<br>åŸæ ¼å¼: ${file.type || 'æœªçŸ¥'} | åŸå¤§å°: ${(file.size / 1024).toFixed(1)}KB<br>è½¬æ¢å: WAV 16kHz å•å£°é“ | å¤§å°: ${(wavBlob.size / 1024).toFixed(1)}KB`;
                playerEl.src = URL.createObjectURL(wavBlob);
                playerEl.style.display = 'block';
                await audioContext.close();
            } catch (error) {
                infoEl.innerHTML = `âŒ è½¬æ¢å¤±è´¥: ${error.message}`;
                convertedAudio[section] = null;
            }
        }

        function audioBufferToWav(buffer) {
            const numChannels = buffer.numberOfChannels;
            const sampleRate = buffer.sampleRate;
            const format = 1;
            const bitDepth = 16;
            const bytesPerSample = bitDepth / 8;
            const blockAlign = numChannels * bytesPerSample;
            const data = buffer.getChannelData(0);
            const samples = data.length;
            const dataSize = samples * bytesPerSample;
            const bufferSize = 44 + dataSize;
            const arrayBuffer = new ArrayBuffer(bufferSize);
            const view = new DataView(arrayBuffer);
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, format, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * blockAlign, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitDepth, true);
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);
            let offset = 44;
            for (let i = 0; i < samples; i++) {
                const sample = Math.max(-1, Math.min(1, data[i]));
                view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                offset += 2;
            }
            return new Blob([arrayBuffer], { type: 'audio/wav' });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        async function toggleRecording(section) {
            const rec = recorders[section];
            const btn = document.getElementById(`${section}RecordBtn`);
            if (!rec.isRecording) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: { sampleRate: TARGET_SAMPLE_RATE, channelCount: 1 } });
                    rec.mediaRecorder = new MediaRecorder(stream);
                    rec.audioChunks = [];
                    setupVisualizer(section, stream);
                    rec.mediaRecorder.ondataavailable = (e) => rec.audioChunks.push(e.data);
                    rec.mediaRecorder.onstop = async () => {
                        const blob = new Blob(rec.audioChunks, { type: 'audio/webm' });
                        const audioContext = new AudioContext({ sampleRate: TARGET_SAMPLE_RATE });
                        const arrayBuffer = await blob.arrayBuffer();
                        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                        const wavBlob = audioBufferToWav(audioBuffer);
                        rec.blob = wavBlob;
                        convertedAudio[section] = wavBlob;
                        const player = document.getElementById(`${section}MicPlayer`);
                        player.src = URL.createObjectURL(wavBlob);
                        player.style.display = 'block';
                        stream.getTracks().forEach(track => track.stop());
                        await audioContext.close();
                    };
                    rec.mediaRecorder.start();
                    rec.isRecording = true;
                    rec.seconds = 0;
                    btn.textContent = 'â¹ï¸ åœæ­¢å½•éŸ³';
                    btn.classList.add('recording');
                    rec.timer = setInterval(() => {
                        rec.seconds++;
                        document.getElementById(`${section}RecordTime`).textContent = `${Math.floor(rec.seconds / 60).toString().padStart(2, '0')}:${(rec.seconds % 60).toString().padStart(2, '0')}`;
                    }, 1000);
                } catch (err) {
                    alert('æ— æ³•è®¿é—®éº¦å…‹é£: ' + err.message);
                }
            } else {
                rec.mediaRecorder.stop();
                rec.isRecording = false;
                clearInterval(rec.timer);
                btn.textContent = 'ğŸ™ï¸ å¼€å§‹å½•éŸ³';
                btn.classList.remove('recording');
            }
        }

        function setupVisualizer(section, stream) {
            const canvas = document.getElementById(`${section}Visualizer`);
            const ctx = canvas.getContext('2d');
            const audioCtx = new AudioContext();
            const analyser = audioCtx.createAnalyser();
            audioCtx.createMediaStreamSource(stream).connect(analyser);
            analyser.fftSize = 256;
            const dataArray = new Uint8Array(analyser.frequencyBinCount);
            function draw() {
                if (!recorders[section].isRecording) return;
                requestAnimationFrame(draw);
                analyser.getByteFrequencyData(dataArray);
                ctx.fillStyle = '#f0f0f0';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                const barWidth = (canvas.width / dataArray.length) * 2.5;
                let x = 0;
                for (let i = 0; i < dataArray.length; i++) {
                    ctx.fillStyle = `rgb(102, ${126 + dataArray[i] / 2}, 234)`;
                    ctx.fillRect(x, canvas.height - (dataArray[i] / 255) * canvas.height, barWidth, (dataArray[i] / 255) * canvas.height);
                    x += barWidth + 1;
                }
            }
            draw();
        }

        function getAudioData(section) {
            if (activeTab[section] === 'file') return convertedAudio[section];
            return recorders[section].blob;
        }

        function getConfig() {
            return {
                apiUrl: document.getElementById('apiUrl').value.replace(/\/$/, ''),
                apiToken: document.getElementById('apiToken').value
            };
        }

        function showResult(elementId, data, isSuccess) {
            const el = document.getElementById(elementId);
            el.style.display = 'block';
            el.className = 'result ' + (isSuccess ? 'success' : 'error');
            el.innerHTML = '<pre>' + JSON.stringify(data, null, 2) + '</pre>';
        }

        async function checkHealth() {
            const config = getConfig();
            const statusEl = document.getElementById('serviceStatus');
            try {
                const response = await fetch(`${config.apiUrl}/voiceprint/health?key=${config.apiToken}`);
                const data = await response.json();
                statusEl.textContent = 'åœ¨çº¿';
                statusEl.className = 'status online';
                showResult('healthResult', data, true);
            } catch (error) {
                statusEl.textContent = 'ç¦»çº¿';
                statusEl.className = 'status offline';
                showResult('healthResult', { error: error.message }, false);
            }
        }

        async function registerVoiceprint() {
            const config = getConfig();
            const speakerId = document.getElementById('registerSpeakerId').value;
            const audioData = getAudioData('register');
            if (!speakerId) { alert('è¯·è¾“å…¥è¯´è¯äºº ID'); return; }
            if (!audioData) { alert('è¯·é€‰æ‹©éŸ³é¢‘æ–‡ä»¶æˆ–å½•åˆ¶å£°éŸ³'); return; }
            const formData = new FormData();
            formData.append('speaker_id', speakerId);
            formData.append('file', audioData, 'audio.wav');
            try {
                const response = await fetch(`${config.apiUrl}/voiceprint/register`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${config.apiToken}` },
                    body: formData
                });
                const data = await response.json();
                showResult('registerResult', data, response.ok);
            } catch (error) {
                showResult('registerResult', { error: error.message }, false);
            }
        }

        async function identifyVoiceprint() {
            const config = getConfig();
            const audioData = getAudioData('identify');
            let speakerIds = document.getElementById('identifySpeakerIds').value.trim();
            if (!audioData) { alert('è¯·é€‰æ‹©éŸ³é¢‘æ–‡ä»¶æˆ–å½•åˆ¶å£°éŸ³'); return; }
            const formData = new FormData();
            formData.append('file', audioData, 'audio.wav');
            // ç•™ç©ºåˆ™ä»æ•°æ®åº“å…¨éƒ¨æ¯”å¯¹
            if (speakerIds) {
                formData.append('speaker_ids', speakerIds);
            }
            try {
                const response = await fetch(`${config.apiUrl}/voiceprint/identify`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${config.apiToken}` },
                    body: formData
                });
                const data = await response.json();
                showResult('identifyResult', data, response.ok);
            } catch (error) {
                showResult('identifyResult', { error: error.message }, false);
            }
        }

        async function deleteVoiceprint() {
            const config = getConfig();
            const speakerId = document.getElementById('deleteSpeakerId').value;
            if (!speakerId) { alert('è¯·è¾“å…¥è¯´è¯äºº ID'); return; }
            try {
                const response = await fetch(`${config.apiUrl}/voiceprint/${speakerId}`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `Bearer ${config.apiToken}` }
                });
                const data = await response.json();
                showResult('deleteResult', data, response.ok);
            } catch (error) {
                showResult('deleteResult', { error: error.message }, false);
            }
        }

        async function listVoiceprints() {
            const config = getConfig();
            try {
                const response = await fetch(`${config.apiUrl}/voiceprint/list`, {
                    headers: { 'Authorization': `Bearer ${config.apiToken}` }
                });
                const data = await response.json();

                // æ ¼å¼åŒ–æ˜¾ç¤º
                if (response.ok && data.voiceprints) {
                    let html = `<div style="margin-bottom:10px;"><strong>å…± ${data.total} ä¸ªå·²æ³¨å†Œå£°çº¹</strong></div>`;
                    if (data.voiceprints.length > 0) {
                        html += '<table style="width:100%;border-collapse:collapse;font-size:13px;">';
                        html += '<tr style="background:#667eea;color:white;"><th style="padding:8px;text-align:left;">è¯´è¯äººID</th><th style="padding:8px;text-align:left;">æ³¨å†Œæ—¶é—´</th></tr>';
                        data.voiceprints.forEach((v, i) => {
                            const bg = i % 2 === 0 ? '#f8f9fa' : '#ffffff';
                            html += `<tr style="background:${bg};"><td style="padding:8px;">${v.speaker_id}</td><td style="padding:8px;">${v.created_at || '-'}</td></tr>`;
                        });
                        html += '</table>';
                    }
                    document.getElementById('deleteResult').style.display = 'block';
                    document.getElementById('deleteResult').className = 'result success';
                    document.getElementById('deleteResult').innerHTML = html;
                } else {
                    showResult('deleteResult', data, response.ok);
                }
            } catch (error) {
                showResult('deleteResult', { error: error.message }, false);
            }
        }

        async function diarizeVoiceprint() {
            const config = getConfig();
            const audioData = getAudioData('diarize');
            let speakerIds = document.getElementById('diarizeSpeakerIds').value.trim();
            if (!audioData) { alert('è¯·é€‰æ‹©éŸ³é¢‘æ–‡ä»¶æˆ–å½•åˆ¶å£°éŸ³'); return; }
            const formData = new FormData();
            formData.append('file', audioData, 'audio.wav');
            formData.append('speaker_ids', speakerIds);
            const btn = document.getElementById('diarizeBtn');
            btn.disabled = true;
            btn.textContent = 'â³ è¯†åˆ«ä¸­...';
            try {
                const response = await fetch(`${config.apiUrl}/voiceprint/diarize`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${config.apiToken}` },
                    body: formData
                });
                const data = await response.json();
                if (response.ok && data.segments) {
                    let html = `<div style="margin-bottom:10px;"><strong>æ£€æµ‹åˆ° ${data.speaker_count} ä¸ªè¯´è¯äººï¼Œå…± ${data.segments.length} ä¸ªç‰‡æ®µ</strong></div>`;
                    html += '<table style="width:100%;border-collapse:collapse;font-size:13px;">';
                    html += '<tr style="background:#667eea;color:white;"><th style="padding:8px;text-align:left;">æ—¶é—´æ®µ</th><th style="padding:8px;text-align:left;">è¯†åˆ«ç»“æœ</th><th style="padding:8px;text-align:left;">ç›¸ä¼¼åº¦</th><th style="padding:8px;text-align:left;">åˆ†ç¦»æ ‡ç­¾</th></tr>';
                    data.segments.forEach((seg, i) => {
                        const bgColor = i % 2 === 0 ? '#f8f9fa' : '#ffffff';
                        const speakerDisplay = seg.speaker_id || '<span style="color:#999;">æœªè¯†åˆ«</span>';
                        const scoreDisplay = seg.score > 0 ? (seg.score * 100).toFixed(1) + '%' : '-';
                        html += `<tr style="background:${bgColor};"><td style="padding:8px;">${seg.start.toFixed(2)}s - ${seg.end.toFixed(2)}s</td><td style="padding:8px;">${speakerDisplay}</td><td style="padding:8px;">${scoreDisplay}</td><td style="padding:8px;">${seg.diarization_label}</td></tr>`;
                    });
                    html += '</table>';
                    const el = document.getElementById('diarizeResult');
                    el.style.display = 'block';
                    el.className = 'result success';
                    el.innerHTML = html;
                } else {
                    showResult('diarizeResult', data, response.ok);
                }
            } catch (error) {
                showResult('diarizeResult', { error: error.message }, false);
            } finally {
                btn.disabled = false;
                btn.textContent = 'å¤šäººè¯†åˆ«';
            }
        }

        async function conversationRecognize() {
            const config = getConfig();
            // æ ¹æ®å½“å‰æ¨¡å¼è·å–éŸ³é¢‘æ•°æ®
            let audioData;
            if (currentConversationMode === 'file') {
                audioData = convertedAudio['conversation'];
            } else if (currentConversationMode === 'record') {
                audioData = recorders['conversation'].blob || convertedAudio['conversation'];
            }
            let speakerIds = document.getElementById('conversationSpeakerIds').value.trim();
            if (!audioData) { alert('è¯·é€‰æ‹©éŸ³é¢‘æ–‡ä»¶æˆ–å½•åˆ¶å£°éŸ³'); return; }
            const formData = new FormData();
            formData.append('file', audioData, 'audio.wav');
            formData.append('speaker_ids', speakerIds);
            const btn = currentConversationMode === 'file' ? document.getElementById('conversationFileBtn') : document.getElementById('conversationRecordSubmitBtn');
            btn.disabled = true;
            btn.textContent = 'â³ è¯†åˆ«ä¸­...';
            try {
                const response = await fetch(`${config.apiUrl}/voiceprint/conversation`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${config.apiToken}` },
                    body: formData
                });
                const data = await response.json();
                if (response.ok && data.segments) {
                    let html = `<div style="margin-bottom:15px;"><strong>ğŸ¯ æ£€æµ‹åˆ° ${data.speaker_count} ä¸ªè¯´è¯äººï¼Œå…± ${data.segments.length} ä¸ªå¯¹è¯ç‰‡æ®µ</strong></div>`;

                    // å¯¹è¯è®°å½•è¡¨æ ¼
                    html += '<table style="width:100%;border-collapse:collapse;font-size:13px;margin-bottom:20px;">';
                    html += '<tr style="background:#667eea;color:white;"><th style="padding:8px;text-align:left;">æ—¶é—´</th><th style="padding:8px;text-align:left;">è¯´è¯äºº</th><th style="padding:8px;text-align:left;">ç›¸ä¼¼åº¦</th><th style="padding:8px;text-align:left;">å†…å®¹</th></tr>';
                    data.segments.forEach((seg, i) => {
                        const bgColor = i % 2 === 0 ? '#f8f9fa' : '#ffffff';
                        const speakerDisplay = seg.speaker_id || `<span style="color:#999;">${seg.diarization_label}</span>`;
                        const scoreDisplay = seg.score > 0 ? (seg.score * 100).toFixed(1) + '%' : '-';
                        const textDisplay = seg.text || '<span style="color:#999;">ï¼ˆæ— è½¬å†™ï¼‰</span>';
                        html += `<tr style="background:${bgColor};">
                            <td style="padding:8px;white-space:nowrap;">${seg.start.toFixed(1)}s - ${seg.end.toFixed(1)}s</td>
                            <td style="padding:8px;">${speakerDisplay}</td>
                            <td style="padding:8px;">${scoreDisplay}</td>
                            <td style="padding:8px;">${textDisplay}</td>
                        </tr>`;
                    });
                    html += '</table>';

                    // å®Œæ•´å¯¹è¯æ–‡æœ¬
                    if (data.transcript) {
                        html += '<div style="background:#f0f7ff;padding:15px;border-radius:8px;border-left:4px solid #667eea;">';
                        html += '<strong style="display:block;margin-bottom:10px;">ğŸ“ å®Œæ•´å¯¹è¯è®°å½•ï¼š</strong>';
                        html += '<pre style="white-space:pre-wrap;word-wrap:break-word;margin:0;font-family:inherit;line-height:1.6;">' + data.transcript + '</pre>';
                        html += '</div>';
                    }

                    const el = document.getElementById('conversationResult');
                    el.style.display = 'block';
                    el.className = 'result success';
                    el.innerHTML = html;
                } else {
                    showResult('conversationResult', data, response.ok);
                }
            } catch (error) {
                showResult('conversationResult', { error: error.message }, false);
            } finally {
                btn.disabled = false;
                btn.textContent = currentConversationMode === 'file' ? 'ğŸ¯ è¯†åˆ«å¯¹è¯' : 'ğŸ¯ è¯†åˆ«å½•éŸ³';
            }
        }

        // ========== å®æ—¶å¯¹è¯è¯†åˆ« ==========
        let realtimeWs = null;
        let realtimeStream = null;
        let realtimeProcessor = null;
        let realtimeContext = null;
        let realtimeTimer = null;
        let realtimeSeconds = 0;
        let isRealtimeRunning = false;

        // ç”¨äºåˆå¹¶åŒä¸€è¯´è¯äººè¿ç»­æ¶ˆæ¯
        let lastSpeaker = null;
        let lastMessageEl = null;
        let speakerColors = {};
        const colorPalette = ['#667eea', '#28a745', '#dc3545', '#fd7e14', '#6f42c1', '#20c997', '#e83e8c'];
        let colorIndex = 0;

        function getSpeakerColor(speaker) {
            if (!speakerColors[speaker]) {
                speakerColors[speaker] = colorPalette[colorIndex % colorPalette.length];
                colorIndex++;
            }
            return speakerColors[speaker];
        }

        async function toggleRealtime() {
            if (isRealtimeRunning) {
                stopRealtime();
            } else {
                await startRealtime();
            }
        }

        async function startRealtime() {
            const config = getConfig();
            const speakerIds = document.getElementById('conversationSpeakerIds').value.trim();
            const btn = document.getElementById('realtimeBtn');
            const statusEl = document.getElementById('realtimeStatus');
            const messagesEl = document.getElementById('realtimeMessages');

            // é‡ç½®çŠ¶æ€
            lastSpeaker = null;
            lastMessageEl = null;
            speakerColors = {};
            colorIndex = 0;

            try {
                // è·å–éº¦å…‹é£æƒé™
                realtimeStream = await navigator.mediaDevices.getUserMedia({
                    audio: { sampleRate: TARGET_SAMPLE_RATE, channelCount: 1 }
                });

                // å»ºç«‹ WebSocket è¿æ¥
                const wsUrl = config.apiUrl.replace('http', 'ws') + `/voiceprint/realtime?token=${config.apiToken}&speaker_ids=${speakerIds}`;
                realtimeWs = new WebSocket(wsUrl);

                realtimeWs.onopen = () => {
                    statusEl.textContent = 'å·²è¿æ¥';
                    statusEl.style.color = '#28a745';
                    messagesEl.innerHTML = '<div style="color:#666;text-align:center;padding:20px;">ğŸ¤ å¼€å§‹è¯´è¯...</div>';

                    // å¼€å§‹å‘é€éŸ³é¢‘æ•°æ®
                    startAudioCapture();
                };

                realtimeWs.onmessage = (event) => {
                    const result = JSON.parse(event.data);
                    const speaker = result.speaker_id || 'æœªçŸ¥';
                    const text = result.text || '';
                    const score = result.score > 0 ? (result.score * 100).toFixed(0) : 0;

                    // å¦‚æœæ²¡æœ‰è¯†åˆ«åˆ°æ–‡å­—ï¼Œè·³è¿‡æ˜¾ç¤º
                    if (!text.trim()) return;

                    // æ¸…é™¤åˆå§‹æç¤º
                    if (messagesEl.querySelector('div[style*="text-align:center"]')) {
                        messagesEl.innerHTML = '';
                    }

                    const speakerColor = getSpeakerColor(speaker);
                    const isKnown = result.speaker_id && result.speaker_id !== '';
                    const bgColor = isKnown ? '#e8f5e9' : '#fff3e0';

                    // å¦‚æœæ˜¯åŒä¸€ä¸ªè¯´è¯äººï¼Œè¿½åŠ åˆ°ä¸Šä¸€æ¡æ¶ˆæ¯
                    if (speaker === lastSpeaker && lastMessageEl) {
                        const textEl = lastMessageEl.querySelector('.msg-text');
                        textEl.innerHTML += ' ' + text;
                    } else {
                        // æ–°è¯´è¯äººï¼Œåˆ›å»ºæ–°çš„æ¶ˆæ¯æ°”æ³¡ï¼ˆå¾®ä¿¡é£æ ¼ï¼‰
                        const msgDiv = document.createElement('div');
                        msgDiv.style.cssText = 'display:flex;margin-bottom:12px;align-items:flex-start;';

                        // å¤´åƒ
                        const avatar = document.createElement('div');
                        avatar.style.cssText = `width:36px;height:36px;border-radius:50%;background:${speakerColor};color:white;display:flex;align-items:center;justify-content:center;font-size:14px;font-weight:bold;flex-shrink:0;margin-right:10px;`;
                        avatar.textContent = speaker.charAt(0).toUpperCase();

                        // æ¶ˆæ¯å†…å®¹åŒº
                        const contentDiv = document.createElement('div');
                        contentDiv.style.cssText = 'flex:1;max-width:calc(100% - 50px);';

                        // è¯´è¯äººåç§°å’Œç½®ä¿¡åº¦
                        const nameDiv = document.createElement('div');
                        nameDiv.style.cssText = `font-size:12px;color:${speakerColor};margin-bottom:4px;font-weight:600;`;
                        nameDiv.innerHTML = speaker + (score > 0 ? ` <span style="color:#999;font-weight:normal;">(${score}%)</span>` : '');

                        // æ¶ˆæ¯æ°”æ³¡
                        const bubbleDiv = document.createElement('div');
                        bubbleDiv.style.cssText = `background:${bgColor};padding:10px 14px;border-radius:0 12px 12px 12px;display:inline-block;max-width:100%;word-wrap:break-word;line-height:1.5;`;
                        bubbleDiv.innerHTML = `<span class="msg-text">${text}</span>`;

                        contentDiv.appendChild(nameDiv);
                        contentDiv.appendChild(bubbleDiv);
                        msgDiv.appendChild(avatar);
                        msgDiv.appendChild(contentDiv);

                        messagesEl.appendChild(msgDiv);
                        lastMessageEl = msgDiv;
                        lastSpeaker = speaker;
                    }

                    messagesEl.scrollTop = messagesEl.scrollHeight;
                };

                realtimeWs.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    statusEl.textContent = 'è¿æ¥é”™è¯¯';
                    statusEl.style.color = '#dc3545';
                };

                realtimeWs.onclose = () => {
                    statusEl.textContent = 'å·²æ–­å¼€';
                    statusEl.style.color = '#666';
                    stopRealtime();
                };

                // æ›´æ–°UI
                isRealtimeRunning = true;
                btn.textContent = 'â¹ï¸ åœæ­¢è¯†åˆ«';
                btn.style.background = 'linear-gradient(135deg, #dc3545 0%, #c82333 100%)';
                btn.classList.add('recording');

                // å¯åŠ¨è®¡æ—¶å™¨
                realtimeSeconds = 0;
                realtimeTimer = setInterval(() => {
                    realtimeSeconds++;
                    document.getElementById('realtimeTime').textContent =
                        `${Math.floor(realtimeSeconds / 60).toString().padStart(2, '0')}:${(realtimeSeconds % 60).toString().padStart(2, '0')}`;
                }, 1000);

                // è®¾ç½®å¯è§†åŒ–
                setupRealtimeVisualizer(realtimeStream);

            } catch (error) {
                alert('å¯åŠ¨å®æ—¶è¯†åˆ«å¤±è´¥: ' + error.message);
                stopRealtime();
            }
        }

        function startAudioCapture() {
            console.log('å¼€å§‹éŸ³é¢‘æ•è·...');
            realtimeContext = new AudioContext({ sampleRate: TARGET_SAMPLE_RATE });
            const source = realtimeContext.createMediaStreamSource(realtimeStream);

            // åˆ›å»º ScriptProcessor æ¥è·å–åŸå§‹éŸ³é¢‘æ•°æ®
            const bufferSize = 4096; // å¢å¤§ç¼“å†²åŒº
            realtimeProcessor = realtimeContext.createScriptProcessor(bufferSize, 1, 1);

            let chunkCount = 0;
            realtimeProcessor.onaudioprocess = (e) => {
                if (!realtimeWs || realtimeWs.readyState !== WebSocket.OPEN) {
                    console.log('WebSocketæœªå°±ç»ªï¼Œè·³è¿‡å‘é€');
                    return;
                }

                const inputData = e.inputBuffer.getChannelData(0);
                // è½¬æ¢ä¸º 16bit PCM
                const pcmData = new Int16Array(inputData.length);
                for (let i = 0; i < inputData.length; i++) {
                    pcmData[i] = Math.max(-32768, Math.min(32767, inputData[i] * 32768));
                }

                // å‘é€éŸ³é¢‘æ•°æ®
                realtimeWs.send(pcmData.buffer);
                chunkCount++;
                if (chunkCount % 10 === 0) {
                    console.log(`å·²å‘é€ ${chunkCount} ä¸ªéŸ³é¢‘å—`);
                }
            };

            source.connect(realtimeProcessor);
            realtimeProcessor.connect(realtimeContext.destination);
            console.log('éŸ³é¢‘æ•è·å·²å¯åŠ¨');
        }

        function stopRealtime() {
            const btn = document.getElementById('realtimeBtn');

            // å…³é—­ WebSocket
            if (realtimeWs) {
                realtimeWs.close();
                realtimeWs = null;
            }

            // åœæ­¢éŸ³é¢‘å¤„ç†
            if (realtimeProcessor) {
                realtimeProcessor.disconnect();
                realtimeProcessor = null;
            }

            if (realtimeContext) {
                realtimeContext.close();
                realtimeContext = null;
            }

            // åœæ­¢éº¦å…‹é£
            if (realtimeStream) {
                realtimeStream.getTracks().forEach(track => track.stop());
                realtimeStream = null;
            }

            // åœæ­¢è®¡æ—¶å™¨
            if (realtimeTimer) {
                clearInterval(realtimeTimer);
                realtimeTimer = null;
            }

            // æ›´æ–°UI
            isRealtimeRunning = false;
            btn.textContent = 'âš¡ å¼€å§‹å®æ—¶è¯†åˆ«';
            btn.style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
            btn.classList.remove('recording');
        }

        function setupRealtimeVisualizer(stream) {
            const canvas = document.getElementById('realtimeVisualizer');
            const ctx = canvas.getContext('2d');
            const audioCtx = new AudioContext();
            const analyser = audioCtx.createAnalyser();
            audioCtx.createMediaStreamSource(stream).connect(analyser);
            analyser.fftSize = 256;
            const dataArray = new Uint8Array(analyser.frequencyBinCount);

            function draw() {
                if (!isRealtimeRunning) return;
                requestAnimationFrame(draw);
                analyser.getByteFrequencyData(dataArray);
                ctx.fillStyle = '#f0f0f0';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                const barWidth = (canvas.width / dataArray.length) * 2.5;
                let x = 0;
                for (let i = 0; i < dataArray.length; i++) {
                    ctx.fillStyle = `rgb(40, ${167 + dataArray[i] / 3}, 69)`;
                    ctx.fillRect(x, canvas.height - (dataArray[i] / 255) * canvas.height, barWidth, (dataArray[i] / 255) * canvas.height);
                    x += barWidth + 1;
                }
            }
            draw();
        }

        window.onload = () => checkHealth();
    </script>
</body>

</html>